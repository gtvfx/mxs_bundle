/***************************************************************************************************Author:				Gavyn ThompsonCompany:				GTVFXWebsite:				www.gtvfx.comEmail:				gthompson@gtvfx.comScriptVersion:			v1.00Updated:				09/16/2014[Purpose]Manage scene materials***************************************************************************************************/try(destroyDialog _matInst.ro)catch()struct materialInstancer(	self,	ro,	ro_prog,	rcm_uiBar,	matArr = #(),		fn SceneRedraw state = -- state = #on or #off	(		/* 		Toggle scene redraw		Takes into account the level to which redraw was previously disabled		 */		case state of		(			#on:			(				while IsSceneRedrawDisabled() do				(					EnableSceneRedraw()				)			)			#off:DisableSceneRedraw()		)	),	fn Mat_ResetMEdit_FN =	(		macros.run "Medit Tools" "clear_medit_slots"	),	fn Mat_RestoreMedit =	(		macros.run "Medit Tools" "restore_medit_slots"	),	fn GetMatByName matName =	(		mat = (for i in sceneMaterials where matchPattern i.name pattern:matName collect i)[1]		mat	),	fn PutMatToMedit mat index:1 =	(		MatEditor.mode = #basic		MatEditor.Open()		meditMaterials[index] = mat		True	),	fn SME_createViewForMat mat =	(		MatEditor.mode = #advanced		MatEditor.Open()		if (sme.GetViewByName mat.name) == 0 then		(			sme.CreateView mat.name			newView = sme.GetView (sme.GetViewByName mat.name)			newView.CreateNode mat [0,0]			True		)		else		(					str = stringStream ""			format "***** Node view % already exists *****\n" mat.name to:str			messageBox (str as string) title:"GTVFX: Error"			False		)	),	fn GenPropStream nd stream:undefined =	(		prps = #()		if stream == undefined then stream = "" as stringstream		try(prps = getPropNames nd)catch()		for p in prps do		(			val = try(getProperty nd p)catch(undefined)			if val == undefined then continue			if classOf val == ArrayParameter then			(				format "%:%\n" p "ArrayParameter" to:stream 			)			else			(				format "%:%\n" p val to:stream				genPropStream val stream:stream			)		)		stream	),	fn GenPropStreamForTexmap map stream:undefined =	(		if stream == undefined then stream = stringStream ""		numSubTexmaps = (getNumSubTexmaps map)		if numSubTexmaps != 0 then		(			for i = 1 to numSubTexmaps do			(				tMap = (getSubTexmap map i)				if tMap != undefined then				(					GenPropStreamForTexmap tMap stream:stream				)			)		)		genPropStream map stream:stream		stream	),	fn GenPropStreamForMaterial mat stream:undefined =	(		if mat == undefined then return False		if SuperClassOf mat != Material then return False		--format "***** Material: % *****\n" mat.name		if stream == undefined then stream = stringStream ""		numSubMats = (getNumSubMtls mat)		if numSubMats != 0 then		(			for i = 1 to numSubMats do			(				genPropStreamForMaterial (getSubMtl mat i) stream:stream			)		)				numSubTexmaps = (getNumSubTexmaps mat)		if numSubTexmaps != 0 then		(			for i = 1 to numSubTexmaps do			(				tMap = (getSubTexmap mat i)				if tMap != undefined then				(					genPropStreamForTexmap tMap stream:stream				)			)		)				genPropStream mat stream:stream		stream	),	fn GenHashForMat mat =	(		str = GenPropStreamForMaterial mat		str = tolower (str as string)		out = (getHashValue str 0)		out	),	fn GenHashForObj obj =	(		str = genPropStream obj		str = tolower (str as string)		out = (getHashValue str 0)		out	),	fn InstanceMaxObjects instArr =	(		for h in instArr do		(			for i = 2 to h.count do replaceInstances h[i] h[1]		)		true	),	fn GenHashInstanceArr maxObjArr =	(		instArr = #()		hash = #()				progressStart "Comparing Materials:"		perc = (100.0 / maxObjArr.count)		percentu = perc			for i in maxObjArr do		(			if (getProgressCancel()) then			(				progressEnd()				return #()			)			if SuperClassOf i != material then continue			hashVal = GenHashForMat i			indx = finditem hash hashVal			case indx of			(				0:				(					append hash hashVal					append instArr #(i)				)				default:				(					append instArr[indx] i				)			)			progressUpdate percentu			percentu += perc		)		progressEnd()		instArr	),	fn DummySaveReset =	(		dummyFile = ((getDir #temp) + "\\_Temp.max")		try(saveNodes #() dummyFile)catch()		if doesFileExist dummyFile then deleteFile dummyFile	),	fn menuBar =	(		rcmenu rcm_uiBar		(			local self			subMenu "Tools"			(				menuItem itm_getDups "Assess Duplicate Loaders"				menuItem itm_instance "Instance Loaders"				separator sep_mb_1a				menuItem itm_removeMissing "Remove Unresolved Loaders"				menuItem itm_mapNames "Rename Map Loaders"			)			on itm_getDups picked do			(				--self.ro.dNtab_show.selectedIndex = 1				colArr = #()				append colArr #(#Text,"Map Name",True,#left)				append colArr #(#Text, "Dups",True,#center)				append colArr #(#Text, "Filename",True,#left)				append colArr #(#Text,"Format",True,#center)				self.ro.initDgv self.ro.dgv_data 10 colArr								if not self.mapInstancer then				(					self.getMapLoaders inst:True					self.mapInstancer = True				)				self.ro.drawData self.ro.dgv_data self.mapLoaderArr nested:True				itm_instance.enabled = True			)			on itm_instance picked do			(				self.instanceLoaders data:self.mapLoaderArr 				self.getMapLoaders inst:True				self.ro.drawData self.ro.dgv_data self.mapLoaderArr nested:True			)			on itm_removeMissing picked do			(				clearListener()				for i in sceneMaterials do				(					self.removeImageLoadersWithMissingFiles i				)				format "***** % files removed *****\n" self.missingFileCount				self.ro.refreshDataGrid self.ro.dgv_data pForce:True			)			on itm_mapNames picked do			(				self.renameMapLoadersToFileName()			)			fn _init pself =			(				self = pself				itm_instance.enabled = False			)		)		rcm_uiBar	),	fn UiDeps =	(		rollout ro_deps "Dependents" width:500		(			local self						fn _init pself =			(				self = pself			)		)		createDialog ro_deps		ro_deps._init self	),	fn UiMatStats =	(		False	),	fn UiProg =	(		rollout ro_prog "" width:500		(			local self			label lbl_prg "Drawing Data:" align:#left			progressBar prg_main color:orange			fn _init pself =			(				self = pself			)		)		createDialog ro_prog		ro_prog._init self	),	fn Ui =	(		rollout ro "Material Instancer" width:450		(			local self			local uiDic			local initSize			local rcm_UI			local dnToolTip			local clrWindow = ((colorMan.getColor #window)*255)			local clrText = ((colorMan.getColor #text)*255)			local ClrBackGround = ((colorMan.getColor #background)*255)			local tHeight = 12			local clr001 = (dotnetClass "System.Drawing.Color").lightGreen			local clr002 = (dotnetClass "System.Drawing.Color").SkyBlue			local clr003 = (dotnetClass "System.Drawing.Color").plum			local clr004 = (dotnetClass "System.Drawing.Color").tomato			local clr005 = (dotnetClass "System.Drawing.Color").dodgerblue			local clr006 = (dotnetClass "System.Drawing.Color").fromARGB 252 145 27			local clr007 = (dotnetClass "System.Drawing.Color").fromARGB 155 250 58			local clr008 = (dotnetClass "System.Drawing.Color").lime			local clr009 = (DotNetClass "System.Drawing.Color").DarkTurquoise			local clr010 = (DotNetClass "System.Drawing.Color").MediumPurple			local defClr = (dotnetClass "System.Drawing.Color").yellow						dotNetControl dNtxt_search "Textbox" height:20			dotNetControl dgv_data "DataGridView" align:#left  height:400 offset:[0,5]			dotNetControl dNlbl_stats "Label" width:200 height:20 offset:[0,10]			dotNetControl dNbtn_proc "button" width:(ro.width-25) height:40						fn normalizeRGB val =			(				if val <0 then val = 0 else if val >255 then val = 255				val			)			fn changeDgvCellColor dgvCell color =			(				newStyle = dotNetObject "System.Windows.Forms.DataGridViewCellStyle"				newStyle.foreColor = color				dgvCell.Style = newStyle			)			fn initToolTip dNetObj caption =			(				if dnTooltip == undefined then				(					dnToolTip = dotnetobject "ToolTip"					dnToolTip.AutoPopDelay = 5000					dnToolTip.InitialDelay = 300					dnToolTip.ReshowDelay = 300					dnToolTip.ShowAlways = true					dnToolTip.IsBalloon = true				)				dnToolTip.SetToolTip dNetObj caption			)			fn DestroyToolTip =			(				dnToolTip				if dnToolTip != undefined then				(					dnToolTip.RemoveAll()					dnToolTip.Dispose()					dnToolTip = undefined				)				True			)			fn SetDotNetWidget dNobj caption fontSize colorOffsetInt:0 fontStyle:#bold foreColor:unsupplied =			(				fStyle = case fontStyle of				(					(#bold):					(						((dotNetClass "System.Drawing.FontStyle").bold)					)					(#italic):					(						((dotNetClass "System.Drawing.FontStyle").italic)					)					(#regular):					(						((dotNetClass "System.Drawing.FontStyle").regular)					)				)				dNobj.text = caption				if foreColor == unsupplied then dNobj.forecolor = dNobj.forecolor.FromArgb clrText.x clrText.y clrText.z else dNobj.forecolor = foreColor				dNobj.backColor = dNobj.backcolor.FromArgb (normalizeRGB (ClrBackGround.x+colorOffsetInt)) (normalizeRGB (ClrBackGround.y+colorOffsetInt)) (normalizeRGB (ClrBackGround.z+colorOffsetInt))				dNobj.Font = dotNetObject "System.Drawing.Font" "Tahoma" fontSize fStyle				dNobj.update()			)			fn InitDnetLbl lbl caption fontsize fontStyle:#bold foreColor:unsupplied =			(				setDotNetWidget lbl caption fontSize fontStyle:fontStyle foreColor:foreColor			)			fn setDataGridColor dgv fontSize =			(				dgv.forecolor = dgv.forecolor.FromArgb clrText.x clrText.y clrText.z				dgv.BackgroundColor = dgv.BackgroundColor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.DefaultCellStyle.BackColor = dgv.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				dgv.AlternatingRowsDefaultCellStyle.BackColor = dgv.AlternatingRowsDefaultCellStyle.BackColor.FromArgb (clrWindow.x-15) (clrWindow.y-15) (clrWindow.z-15)			)			fn initDnetBtn dNbtn caption fontSize style:#popup colorOffsetInt:0 tooltip:"" = 			(				case style of				(					#flat:(dNbtn.flatStyle = dNbtn.flatStyle.flat)					#popup:(dNbtn.flatStyle = dNbtn.flatStyle.popup)					#system:(dNbtn.flatStyle = dNbtn.flatStyle.system)				)				setDotNetWidget dNbtn caption fontSize colorOffsetInt:colorOffsetInt				dNbtn.tag = tooltip				dNbtn.update()			)			fn initTxtBx tbx caption fontSize tooltip:"" =			(				tbx.backcolor = tbx.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				tbx.forecolor = tbx.forecolor.FromArgb clrText.x clrText.y clrText.z				tbx.text = caption				tbx.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				tbx.BorderStyle = (dotNetClass "System.Windows.Forms.BorderStyle").FixedSingle				tbx.MultiLine = false				tbx.AcceptsReturn = false				tbx.AcceptsTab = false				tbx.WordWrap = false				tbx.tag = tooltip				tbx.update()			)			fn drawData dgv dataArr colArr:#() =			(				dgv.Columns.Clear()				for col in colArr do				(					dnNewColumn					case col[1] of					(						(#Text):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewTextBoxColumn"						(#Bool):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewCheckBoxColumn"						default:dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewComboBoxColumn"					)					dnNewColumn.HeaderText = col[2]					dnNewColumn.ReadOnly = col[3]					dnAlignment = dotNetClass "System.Windows.Forms.DataGridViewContentAlignment"					case col[4] of					(						#Right:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleRight						#Center:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleCenter						#Left:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft						default:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft					)					dnNewColumn.sortMode = (dotNetClass "System.Windows.Forms.DataGridViewColumnSortMode").automatic					dgv.columns.add dnNewColumn				)				dgv.rows.clear()				self.uiProg()				perc = (100.0 / dataArr.count)				percentu = perc					format "***** DataArr: % *****\n" dataArr				for a in dataArr do				(					tempRow = dotNetObject "System.Windows.Forms.DataGridViewRow"					dgv.rows.add tempRow					type = try(tolower((classOf a[1]) as string))catch("<NA>")					tempRow.SetValues #(a[1].name, (a.count-1), type)					case type of					(						"standardmaterial":						(							tempRow.DefaultCellStyle.ForeColor = clr001						)						"vraymtl":						(							tempRow.DefaultCellStyle.ForeColor = clr002						)						"vraylightmtl":						(							tempRow.DefaultCellStyle.ForeColor = clr003						)						"vray2sidedmtl":						(							tempRow.DefaultCellStyle.ForeColor = clr004						)						"vrayblendmtl":						(							tempRow.DefaultCellStyle.ForeColor = clr005						)						"vrayfastsss2":						(							tempRow.DefaultCellStyle.ForeColor = clr006						)						"vrayglslmtl":						(							tempRow.DefaultCellStyle.ForeColor = clr007						)						"vraycarpaintmtl":						(							tempRow.DefaultCellStyle.ForeColor = clr008						)						"vrayhairmtl":						(							tempRow.DefaultCellStyle.ForeColor = clr009						)						"multimaterial":						(							tempRow.DefaultCellStyle.ForeColor = clr010						)						default:						(							tempRow.DefaultCellStyle.ForeColor = defClr						)					)					self.ro_prog.prg_main.value = percentu					percentu += perc				)				for c = 0 to (dgv.columns.count-1) do				(					case c of					(						0:						(							dgv.columns.item[c].autoSizeMode = dgv.columns.item[c].autoSizeMode.fill						)						default:						(							dgv.columns.item[c].autoSizeMode = dgv.columns.item[c].autoSizeMode.DisplayedCells						)					)				)				dgv.sort dgv.columns.item[(dgv.columns.count-1)] (dotNetClass "System.ComponentModel.ListSortDirection").ascending				dgv.clearSelection()				dgv.update()				self.ro_prog.prg_main.value = 100				destroyDialog self.ro_prog			)			fn initDgv dgv fontsize tooltip:"" =			(				dgv.ShowCellToolTips = False				dgv.MultiSelect = True				dgv.AllowUserToAddRows = off				dgv.AutoSize = on				dgv.AutoSizeColumnsMode = dgv.AutoSizeColumnsMode.Fill				dgv.ShowEditingIcon = dgv.RowHeadersVisible = off				dnSelectionMode = dotNetClass "System.Windows.Forms.DataGridViewSelectionMode"				dgv.SelectionMode = dnSelectionMode.FullRowSelect 				dgv.AllowUserToResizeRows = False				dgv.AllowUserToOrderColumns = False				dgv.AllowUserToResizeColumns = True				dgv.ColumnHeadersHeightSizeMode = dgv.ColumnHeadersHeightSizeMode.DisableResizing				setDataGridColor dgv fontSize				initToolTip dgv tooltip				dgv.update()			)			fn UpdatedStats =			(				dNlbl_stats.text = ("Total Materials:  " + (self.matArr.count as string))			)			fn refreshDataGrid dgv pforce:False =			(				colArr = #()				append colArr #(#Text,"Material Name",True,#left)				append colArr #(#Text, "Dups",True,#center)				append colArr #(#Text,"Class",True,#center)								if self.matArr.count == 0 or pforce == True then				(					self.matArr = self.genHashInstanceArr sceneMaterials				)				drawData dgv self.matArr colArr:colArr				UpdatedStats()			)			fn getDgvCellValue dgv rowIndex cellIndex =			(				out = dgv.rows.item[rowIndex].cells.item[cellIndex].value				out			)			fn uiMenu =			(				rcmenu rcm_UI				(					local self					local rowIndex					local cellIndex										menuItem item_putToMedit "Put To Current Medit Slot"					separator sep_1a					menuItem item_putToSlate "Create Slate View"										on item_putToMedit picked do					(						self.putMatToMedit (self.getMatByName (getDgvCellValue dgv_data rowIndex 0)) index:activeMeditSlot					)					on item_putToSlate picked do 					(						self.SME_createViewForMat (self.getMatByName (getDgvCellValue dgv_data rowIndex 0))					)					fn _init pself row:unsupplied cell:unsupplied =					(						self = pself						rowIndex = row						cellIndex = cell					)				)				rcm_UI			)			fn _init pself =			(				self = pself				initTxtBx dNtxt_search "Search" 12 tooltip:"Filter rows\nDouble-Click to clear contents"				initDnetBtn dNbtn_proc "Instance Materials" 11 style:#popup colorOffsetInt:10 tooltip:"Instance all materials"				initDnetLbl dNlbl_stats "Total Materials:" 9 fontStyle:#regular foreColor:((dotnetClass "System.Drawing.Color").fromARGB 255 127.5 0)				initDgv dgv_data 10				refreshDataGrid dgv_data			)			fn filterDataGridRows dgv cellIndex filterTxt = -- function for the search feature			(				if filterTxt == "" or filterTxt == "Search" then				(					for i in 0 to dgv.rows.count-1 do					(						dgv.rows.item[i].visible = true					)				)				else				(					for i in 0 to dgv.rows.count-1 do					(						if not matchPattern dgv.rows.item[i].cells.item[cellIndex].value pattern:("*"+filterTxt+"*") then						(							dgv.rows.item[i].visible = false						)						else						(							dgv.rows.item[i].visible = true						)					)				)			)			fn getUiControlName uiControl = 			(				str = (uiControl as string)				uiName = (filterString str ":")[2]				uiName			)			fn GetControlByName controlName =			(				out = (for i in self.ro.controls where matchPattern (i as string) pattern:("*:"+controlName+"*") collect i)[1]				out			)			fn collectUiControls =			(				dic = dotNetObject "System.Collections.Hashtable"				subDic = dotNetObject "System.Collections.Hashtable"				subDic.add "width" ro.width				subDic.add "height" ro.height				dic.add "ui" subDic								for c in ro.controls where (isproperty c #width) and (isproperty c #height) do				(					subDic = dotNetObject "System.Collections.Hashtable"					subDic.add "width" c.width					subDic.add "height" c.height					subDic.add "pos.x" c.pos.x					subDic.add "pos.y" c.pos.y					dic.add (getUiControlName c) subDic				)				dic			)			fn resizeUI val =			(				dif = (val - initSize)				offMult = 1								c = GetControlByName "dNtxt_search"				c.width = (uiDic.item["dNtxt_search"].item["width"] + dif.x)								c = GetControlByName "dgv_data"				c.width = (uiDic.item["dgv_data"].item["width"] + dif.x)				c.height = (uiDic.item["dgv_data"].item["height"] + (dif.y*offMult))								c = GetControlByName "dNbtn_proc"				c.width = (uiDic.item["dNbtn_proc"].item["width"] + dif.x)				c.pos = [uiDic.item["dNbtn_proc"].item["pos.x"],(uiDic.item["dNbtn_proc"].item["pos.y"] + (dif.y*offMult))]									c = GetControlByName "dNlbl_stats"				c.pos = [uiDic.item["dNlbl_stats"].item["pos.x"],(uiDic.item["dNlbl_stats"].item["pos.y"] + (dif.y*offMult))]			)			on chk_sMapName changed state do			(				chk_sFileName.state = not state 			)			on chk_sFileName changed state do			(				chk_sMapName.state = not state 			)			on dgv_data mouseDown args do			(				if args.button == dgv_data.mouseButtons.right then				(					hit = dgv_data.hitTest args.location.x args.location.y					popUpMenu (uiMenu()) pos:mouse.screenPos					rcm_UI._init self row:hit.RowIndex cell:hit.ColumnIndex				)			)			on dNtxt_search keyUp arg do			(				indx = 0				filterDataGridRows dgv_data indx dNtxt_search.text			)			on dNtxt_search MouseDoubleClick arg do			(				dNtxt_search.text = ""				for i in 0 to dgv_data.rows.count-1 do				(					dgv_data.rows.item[i].visible = true				)			)			on dNtxt_search MouseClick arg do			(				if dNtxt_search.text == "Search" then dNtxt_search.text = ""			)			on dNtxt_search MouseEnter arg do			(				initToolTip dNtxt_search dNtxt_search.tag			)			on dNtxt_search MouseLeave arg do			(				destroyToolTip()			)			on dNbtn_proc mouseClick args do			(				if self.matArr.count != 0 then				(					self.SceneRedraw #off					self.instanceMaxObjects self.matArr					self.dummySaveReset()					refreshDataGrid dgv_data pforce:True					self.SceneRedraw #on				)			)			on dNbtn_proc MouseEnter arg do			(				initToolTip dNbtn_proc dNbtn_proc.tag			)			on dNbtn_proc MouseLeave arg do			(				destroyToolTip()			)			on ro open do			(				initSize = [ro.width,ro.height]				uiDic = collectUiControls()			)			on ro help do			(				format "***** Coming Soon *****\n"			)			on ro resized val do			(				resizeUI val			)		)		createDialog ro /* menu:(menuBar()) */ style:#(#style_titlebar, #style_resizing, #style_sunkenedge, #style_sysmenu, #style_minimizebox, #style_maximizebox)		ro._init self		--rcm_uiBar._init self	),	fn _init =	(		self = this		macros.run "Medit Tools" "clear_medit_slots"		ui()	),	init = _init())_matInst = materialInstancer()format "***** Tool Name: _matInst *****\n"