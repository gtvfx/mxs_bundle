/*Scene sanity checks By Gavyn Thompson*/try(destroyDialog SceneSanityChecks.ro)catch()SceneSanityChecks = undefinedstruct qcPlugin(	/* 	Construct for plugin object	 */	title = "",	method = unsupplied,	aux = unsupplied,	active = False,	description = "")struct qcPluginManager(	/* 	The Plugin manager is inherited by the main tool and handles the plugins	 */	_resourcePath, -- Path to folder containing plugin files	_pluginsLoaded = False,	_plugins = #(), -- Array of qcPlugin objects		fn Register title:unsupplied method:unsupplied aux:unsupplied active:true description:"" =	( 		local success = True		if title == unsupplied or method == unsupplied then		(			format "***** Plugin Load Failed *****\n"			return False		)		format "***** Loading Plugin: % *****\n" title		append _plugins (qcPlugin title:title method:method aux:aux active:active description:description)	),		fn init refresh:false =	(		if (not _pluginsLoaded or refresh) then		(			-- Load Plugins			format "--------------------------------------------------------------------------------------------------------------\n"			format "===== Loading Plugins... =====\n"						_plugins = #()						-- Load Plugin Files			local filenames = getFiles (_resourcePath + "plugins/*.ms")			for filename in filenames do filein filename						format "--------------------------------------------------------------------------------------------------------------\n"						-- Load State from INI			--loadCustomState()		)	))struct SceneSanityChecks(	self,	ro,	modalUI = false,	rootHelper,	msgBuffer = "<idle>",	tstMsg = #(),	pluginList = #(#Sanity_DuplicateNames),	---test reslut object arrays	testResults = #(),	testPluginArr = #(),	testFnArr = #(),	testAuxFn = #(),		--	resourcePath = (GetFileNamePath (GetThisScriptFilename())),	plugManager = undefined,			fn RemoveInvalidChars str =	(		charArr = #(".","!","@","#","$","%","^","&","*",";",":",",","?","|","/","\\","\"","'"," ")		for i in charArr do		(			str = SubstituteString str i ""		)		(str as string)	),			fn RegisterTestCheck pluginObj =	(		/* 		Adds a plugin object to a local level array		 */		append testPluginArr pluginObj	),		fn RegisterTestsCode =	(		/* 		Creates the final local level array of plugin objects to be used		 */		if self.plugManager._plugins.count != 0 then		(			for p in self.plugManager._plugins do			(								registerTestCheck p			)		)	),		fn RunTest ro:undefined =	(		/* 		Runs the .method property of each loaded plugin and supplies a message back to the UI with the test result		 */		pass = true		if testResults.count == 0 then		(			testResults = for i = 1 to self.testPluginArr.count collect false			tstMsg = for i = 1 to self.testPluginArr.count collect "none"		)		nmbTestRan = 0		for i = 1 to self.testPluginArr.count do		(			if testResults[i] then continue --if we passed this test before early out..			nmbTestRan += 1			test = self.testPluginArr[i].method			--format "***** Test: % *****\n" test			subItem			if ro != undefined then			(				subItem = ro.dgv_test.rows.item[i-1].cells.item[1]				subItem.value = "Running..."				ro.dgv_test.update()				sleep .1			)			case test() of			(				(true):				(					if subItem != undefined then					(						subItem.value = "Passed"						tstMsg[i] =  "Passed"						self.ro.changeDgvCellColor subItem ((dotnetClass "System.Drawing.Color").fromARGB self.ro.clrText.x self.ro.clrText.y self.ro.clrText.z)					)					testResults[i] = true				)				default:				(					if subitem != undefined then					(						tstMsg[i] =  msgBuffer						subitem.value = "Failed"						self.ro.changeDgvCellColor subItem self.ro.errorClr					)					testResults[i] = false					pass = false				)			)		)		if ro != undefined then ro.dgv_test.update()		format "Number of Test's Run %\n" nmbTestRan		pass	),		-------------ui stuff...	fn Ui modal:False =	(		rollout ro "Scene Sanity Checks" width:500		(			local self			local uiDic			local initSize			local modal			local rcm_test			local dnToolTip			local clrWindow = ((colorMan.getColor #window)*255)			local clrText = ((colorMan.getColor #text)*255)			local ClrBackGround = ((colorMan.getColor #background)*255)			local errorClr = (dotnetClass "System.Drawing.Color").fromARGB 255 52 23			local tests			local sucess = false						dotNetControl dgv_test "DataGridView" height:10			dotNetControl dNlbl_msg "Label" width:(ro.width-25) height:20			dotNetControl dNbtn_run "Button" width:(ro.width-25) height:40						fn NormalizeRGB val =			(				if val <0 then val = 0 else if val >255 then val = 255				val			)			fn InitToolTip dNetObj caption =			(				if dnTooltip == undefined then				(					dnToolTip = dotnetobject "ToolTip"					dnToolTip.AutoPopDelay = 5000					dnToolTip.InitialDelay = 300					dnToolTip.ReshowDelay = 300					dnToolTip.ShowAlways = true					dnToolTip.IsBalloon = true				)				dnToolTip.SetToolTip dNetObj caption			)			fn SetDotNetWidget dNobj caption fontSize colorOffsetInt:0 =			(				dNobj.text = caption				dNobj.forecolor = dNobj.forecolor.FromArgb clrText.x clrText.y clrText.z				dNobj.backColor = dNobj.backcolor.FromArgb (normalizeRGB (ClrBackGround.x+colorOffsetInt)) (normalizeRGB (ClrBackGround.y+colorOffsetInt)) (normalizeRGB (ClrBackGround.z+colorOffsetInt))				dNobj.Font = dotNetObject "System.Drawing.Font" "Tahoma" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)			)			fn InitDnetBtn dNbtn caption fontSize style:#popup colorOffsetInt:0 tooltip:"" =			(				case style of				(					#flat:(dNbtn.flatStyle = dNbtn.flatStyle.flat)					#popup:(dNbtn.flatStyle = dNbtn.flatStyle.popup)					#system:(dNbtn.flatStyle = dNbtn.flatStyle.system)				)				setDotNetWidget dNbtn caption fontSize colorOffsetInt:colorOffsetInt				initToolTip dNbtn tooltip				dNbtn.tag = tooltip				dNbtn.update()			)			fn InitDnetLbl dNlbl caption:"" fontSize:10 tooltip:"" =			(				setDotNetWidget dNlbl caption fontSize				initToolTip dNlbl tooltip				dNlbl.update()			)			fn SetDataGridColor dgv fontSize =			(				dgv.forecolor = dgv.forecolor.FromArgb clrText.x clrText.y clrText.z				dgv.BackgroundColor = dgv.BackgroundColor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.DefaultCellStyle.BackColor = dgv.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				dgv.AlternatingRowsDefaultCellStyle.BackColor = dgv.AlternatingRowsDefaultCellStyle.BackColor.FromArgb (clrWindow.x-15) (clrWindow.y-15) (clrWindow.z-15)			)			fn ChangeDgvCellColor dgvCell color =			(				newStyle = dotNetObject "System.Windows.Forms.DataGridViewCellStyle"				newStyle.foreColor = color				dgvCell.Style = newStyle			)			--			fn DrawData dgv dataArr colArr:#() =			(				/* 				Tells the UI how to display the data				 */				rowSize = 26.75				for col in colArr do				(					dnNewColumn					case col[1] of					(						(#Text):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewTextBoxColumn"						(#Bool):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewCheckBoxColumn"						default:dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewComboBoxColumn"					)					dnNewColumn.HeaderText = col[2]					dnNewColumn.ReadOnly = col[3]					dnAlignment = dotNetClass "System.Windows.Forms.DataGridViewContentAlignment"					case col[4] of					(						#Right:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleRight						#Center:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleCenter						#Left:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft						default:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft					)					dgv.columns.add dnNewColumn				)				for i in 0 to dgv.columns.count-1 do				(					dgv.Columns.item[i].SortMode = (dotNetClass "System.Windows.Forms.DataGridViewColumnSortMode").NotSortable				)				dgv.rows.clear()				for d in dataArr do				(					tName = d.title --substituteString (d as string) "()" ""					tempRow = dotNetObject "System.Windows.Forms.DataGridViewRow"					dgv.rows.add tempRow					tempRow.SetValues #(tName, "idle")					dgv.height += rowSize-2				)				ro.height += dgv.height				dgv.columns.item[0].autoSizeMode = dgv.columns.item[0].autoSizeMode.Fill				dgv.columns.item[1].autoSizeMode = dgv.columns.item[1].autoSizeMode.DisplayedCells				dgv.clearSelection()				dgv.update()			)			fn InitDgv dgv fontsize tooltip:"" =			(				dgv.MultiSelect = False				dgv.AllowUserToAddRows = off				dgv.AutoSize = on				dgv.AutoSizeColumnsMode = dgv.AutoSizeColumnsMode.Fill				dgv.ShowEditingIcon = dgv.RowHeadersVisible = off				dnSelectionMode = dotNetClass "System.Windows.Forms.DataGridViewSelectionMode"				dgv.SelectionMode = dnSelectionMode.FullRowSelect				dgv.AllowUserToResizeRows = false				dgv.AllowUserToOrderColumns = false				dgv.AllowUserToResizeColumns = false				dgv.ColumnHeadersHeightSizeMode = dgv.ColumnHeadersHeightSizeMode.DisableResizing				setDataGridColor dgv fontSize				initToolTip dgv tooltip				dgv.update()			)						fn RcMenuUi funcIndx =			(				/* 				RC Menu programatically created on the fly based on plugin data				 */								funcAr = self.testPluginArr[funcIndx].aux								if funcAr.count == 0 then				(					rcmenu rcm_test					(						menuitem testA "no auxiliary functions have been registered for this test..."						fn _init pself =						(							self = pself						)					)				)				else				(					rcTxt = stringStream ""					st = "rcmenu rcm_test\n(%\n%\n%\n%\n)"					vars = "\n\tlocal self\n\tlocal pluginObj\n" 					items = ""					events = ""					cb = stringStream ""					format "\tfn _init pself =\n\t(\n\t\tself = pself\n\t\tpluginObj = self.testPluginArr[%]\n\t)" funcIndx to:cb					cb = cb as string					-- build items					for f = 1 to funcAr.count do					(						------items						fName = substituteString (self.testPluginArr[funcIndx].aux[f] as string) "()" ""						itemName = (self.RemoveInvalidChars fName)						it = "" as stringstream						format "\tmenuItem %_item \"%\"\n" itemName fName to:it						items += it as string						--events						ev = "" as stringStream						if not (matchPattern fname pattern:"select*") then						(							format "\ton %_item picked do\n\t(\n\t\tpluginObj.aux[%]()\n\t\tself.runTest ro:self.ro\n\t)\n" itemName f to:ev						)						else						(							format "\ton %_item picked do (pluginObj.aux[%]())\n" itemName f to:ev						)						events += ev as string					)					format st vars items events cb to:rcTxt										--format "====== RC Menu =====\n"					--format "%\n" rcTxt										rcm_test = execute (rcTxt as string)				)				rcm_test			)						fn UpdateTestMessage rowIndex =			(				index = (rowIndex + 1)				if self.tstMsg[index] != undefined then				(					dNlbl_msg.text = "Test Messages: "+self.tstMsg[index]				)				else				(					dNlbl_msg.text  = "Test Messages:Idle"				)			)						fn GetUiControlName uiControl = 			(				str = (uiControl as string)				uiName = (filterString str ":")[2]				uiName			)						fn GetControlByName controlName =			(				out = (for i in ro.controls where matchPattern (i as string) pattern:("*:"+controlName+"*") collect i)[1]				out			)						fn CollectUiControls =			(				dic = dotNetObject "System.Collections.Hashtable"				subDic = dotNetObject "System.Collections.Hashtable"				subDic.add "width" ro.width				subDic.add "height" ro.height				dic.add "ui" subDic								for c in ro.controls where (isproperty c #width) and (isproperty c #height) do				(					subDic = dotNetObject "System.Collections.Hashtable"					subDic.add "width" c.width					subDic.add "height" c.height					subDic.add "pos.x" c.pos.x					subDic.add "pos.y" c.pos.y					dic.add (getUiControlName c) subDic				)				dic			)						fn ResizeUI val =			(				dif = (val - initSize)				offMult = 1 -- across value of ui controlls. 3 = 0.3333333, 2 = 0.6666666								c = getControlByName "dgv_test"				c.width = (uiDic.item["dgv_test"].item["width"] + dif.x)				c.height = (uiDic.item["dgv_test"].item["height"] + (dif.y*offMult))									c = getControlByName "dNlbl_msg"				c.width = (uiDic.item["dNlbl_msg"].item["width"] + dif.x)				c.pos = [uiDic.item["dNlbl_msg"].item["pos.x"],(uiDic.item["dNlbl_msg"].item["pos.y"] + (dif.y*offMult))]								c = getControlByName "dNbtn_run"				c.width = (uiDic.item["dNbtn_run"].item["width"] + dif.x)				c.pos = [uiDic.item["dNbtn_run"].item["pos.x"],(uiDic.item["dNbtn_run"].item["pos.y"] + (dif.y*offMult))]			)						fn _init pself modal:False =			(				self = pself				initDnetBtn dNbtn_run "Rerun Failed Tests" 11 style:#popup colorOffsetInt:10 tooltip:""				initDgv dgv_test 10 tooltip:""				colArr = #(#(#text,"Test:",True,#left),#(#text,"Result:",True,#left))				drawData dgv_test self.testPluginArr colArr:colArr				initDnetLbl dNlbl_msg caption:"Test Messages:idle" fontSize:9								success = self.runTest ro:ro								if success and modal then				(					format "All optimization tests passed exiting in 5 seconds.."					sleep 1					destroyDialog ro				)			)						on lv_test itemSelectionChanged x do			(				item = x.item				if self.tstMsg[item.index + 1] != undefined then errLbl.text = "Test Messages:"+self.tstMsg[item.index + 1] else errLbl.text  = "Test Messages:Idle"			)						on dgv_test mouseDown args do			(				hit = dgv_test.hitTest args.location.x args.location.y				if hit.type != hit.type.cell then return False				clickedRow = dgv_test.rows.item[hit.RowIndex]				clickedCell = clickedRow.Cells.item[hit.ColumnIndex]				case (args.button) of				(					(dgv_test.mouseButtons.left):					(						updateTestMessage hit.RowIndex					)					(dgv_test.mouseButtons.right):					(						clickedRow.selected = true						updateTestMessage hit.RowIndex						m = rcMenuUi (hit.RowIndex+1)						popUpMenu m pos:mouse.screenPos						rcm_test._init self					)				)			)						on dNbtn_run mouseClick do			(				if (querybox "Would you like to rerun the tests?") then self.runTest ro:ro			)						on ro open do 			(				initSize = [ro.width,ro.height]				uiDic = collectUiControls()			)						on ro resized val do			(				resizeUI val			)		)		createDialog ro modal:modal		ro._init self modal:modal	),		fn Run modal:False=	(		-- Running the tool in Modal mode prevents any resizing. Do not run this tool in Modal mode		ui modal:modal		True	),		fn RunModal =	(		ui modal:True		ro.sucess	),		fn Init =	(		self = this				self.plugManager = qcPluginManager _resourcePath:resourcePath		self.plugManager.init()				RegisterTestsCode()		Run modal:False		True	))SceneSanityChecks = SceneSanityChecks()SceneSanityChecks.Init()