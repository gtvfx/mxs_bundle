/***************************************************************************************************Copyright (C) 2013 - 2017  Gavyn ThompsonThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation; either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program. if not, see <http://www.gnu.org/licenses/>.***************************************************************************************************//***************************************************************************************************Author:				    Gavyn ThompsonCompany:				GTVFXWebsite:				https://github.com/gtvfxEmail:				    gftvfx@gmail.comScriptVersion:			Updated:				[Purpose]***************************************************************************************************//*__HELP__Constructor: MapInstancerInstantiated Global: MapInstancerMethods:__END__*/mxs.Using "WpfProgressbar"struct MapInstancer(public	debug = True,    startLoaderCount,    endLoaderCount,		fn CollectMaterials excludeList:#(VRaySky) =	(		materialList = for i in sceneMaterials where (findItem excludeList (classOf i)) == 0 collect i	),    	fn GenPropStream nd stream:undefined =	(		prps = #()		if stream == undefined then stream = "" as stringstream		try(prps = getPropNames nd)catch()		for p in prps do		(			try(val = getProperty nd p)catch(val = "")			format "%:%\n" p val to:stream			genPropStream val stream:stream		)		stream	),    	fn GenHashForLoader mapLoader =	(		str = "" as stringStream		str = genPropStream mapLoader		str = tolower (str as string)		out = (getHashValue str 0)		out	),    	fn GetMapLoaders inst:False  =	(		local out = ( GetClassInstances BitMapTexture ) + ( GetClassInstances VRayHDRi )		out	),        fn GetMapLoaderFileName mapLoader =	(        local out        		case ( classOf mapLoader ) of		(			(bitMapTexture):			(				out = mapLoader.fileName			)			(VRayHDRi):			(				out = mapLoader.HDRIMapName			)			default:			(				out = undefined			)		)        		out	),        fn CheckFileName mapLoader =    (        if ( this.GetMapLoaderFileName mapLoader ) == undefined then        (            False        )        else        (            True        )    ),        fn CheckSumMapLoaders mapLoaderArr =    (        local out = #()        local hashArr = #()                local checkSumProg = ::WpfProgressBar caption:"Comparing map loaders" steps:mapLoaderArr.count        checkSumProg.Start()                for map in mapLoaderArr do        (            if ( keyboard.escPressed ) then            (                checkSumProg.End()                exit            )                        checkSumProg.UpdateLabel map.name                        if not ( this.CheckFileName map ) then continue                        local hashVal = this.GenHashForLoader map            local indx = ( finditem hashArr hashVal )                        case indx of            (                0:                (                    append hashArr hashVal                    append out #(map)                )                default:                (                    append out[indx] map                )            )                        checkSumProg.Step()        )                checkSumProg.End()                if this.debug then format "***** CheckSumArr: % *****\n" out                out    ),    	fn InstanceLoaders instArr:unsupplied =	(        SetCommandPanelTaskMode #create        ::_ilmLibrary.BlockUi True        		if instArr == unsupplied then instArr = ( this.CheckSumMapLoaders (this.GetMapLoaders() ) )                local instanceProg = ::WpfProgressBar caption:"Instancing Map Loaders" steps:instArr.count        instanceProg.Start()        		for inst in instArr do		(            instanceProg.UpdateLabel inst[1].name			for i = 2 to inst.count do replaceInstances inst[i] inst[1]			instanceProg.Step()		)                ::_ilmLibrary.BlockUi False        		instanceProg.End()	),    	fn Get_Names name a =	(		append a name	),    	fn CollectMissingFiles =	(		local arr = #()		EnumerateFiles this.Get_Names arr #missing		arr	),    	fn GetMapLoaderByName mapName mapLoaderArr:unsupplied =	(        if mapLoaderArr == unsupplied then mapLoaderArr = ( this.GetMapLoaders() )        		local arr = #()				for map in mapLoaderArr do		(			if ( matchPattern map.name pattern:mapName ) then append arr map		)		arr	),    	fn GetMapLoadersByFileName fName mapLoaderArr:unsupplied =	(		if mapLoaderArr == unsupplied then mapLoaderArr = ( This.GetMapLoaders() )                local arr = #()        		for map in mapLoaderArr do		(            if not ( this.CheckFileName map ) then continue            			case (classOf map) of			(				(VrayHDRi):				(					if ( matchPattern map.HDRIMapName pattern:fName ) then append arr map				)				(BitmapTex):				(					if ( MatchPattern map.fileName pattern:fName ) then append arr map				)			)		)        		arr	),    	fn GetMapLoaderFileNames mapLoaderArr:unsupplied =	(        if mapLoaderArr == unsupplied then mapLoaderArr = ( This.GetMapLoaders() )        		local arr = #()		for map in mapLoaderArr do		(			case (classOf map) of			(				(bitMapTexture):				(					appendIfUnique arr map.fileName				)				(VRayHDRi):				(					appendIfUnique arr map.HDRIMapName				)			)		)		arr	),    	fn GetUsedMaps =	(		local arr = UsedMaps()		arr	),    	fn CollectRefs map =	(		local arr = refs.dependents map		arr	),    	fn GetTexmapRes texFileName =	(		if doesFileExist texFileName then		(			local bMapFile = openBitmap texFileName			local resStr = ((bMapFile.width as string)+"x"+(bMapFile.height as string))			format "***** %: % *****\n" ( GetFileNameFile texFileName ) ( ( bMapFile.width as string )+" x "+( bMapFile.height as string ) )			close bMapFile			resStr		)		else		(			False		)	),    	fn RenameMapLoadersToFileName loaderArr:#() =	(		loaderArr = (getMapLoaders inst:False)		for i in loaderArr do		(			if not (matchPattern i.name pattern:"Map #*") then continue			case (classOf i) of			(				(BitmapTexture):				(					i.name = (getFileNameFile i.fileName)				)				(VrayHDRi):				(					i.name = (getFileNameFile i.HDRIMapName)				)			)		)	),    	fn ViewMap mapLoader =	(		local bm = undefined		case (classOf mapLoader) of		(			(VrayHDRi):			(				bm = bitmapTex fileName:mapLoader.HDRiMapName			)			(BitmapTex):			(				bm = bitmapTex fileName:mapLoader.fileName			)		)		meditMaterials[24] = Standard()		ActiveMeditSlot = 24		MeditMaterials[24] = bm		MatEditor.Open()		bm.viewImage()	),    	fn MenuBar =	(		rcmenu rcm_uiBar		(			local self			subMenu "Tools"			(				menuItem itm_getDups "Assess Duplicate Loaders"				menuItem itm_instance "Instance Loaders"				separator sep_mb_1a				menuItem itm_removeMissing "Remove Unresolved Loaders"				menuItem itm_mapNames "Rename Map Loaders"			)			on itm_getDups picked do			(				--self.ro.dNtab_show.selectedIndex = 1				colAr = #()				append colAr #(#Text,"Map Name",True,#left)				append colAr #(#Text, "Dups",True,#center)				append colAr #(#Text, "Filename",True,#left)				append colAr #(#Text,"Format",True,#center)				self.ro.initDgv self.ro.dgv_data 10 colAr				if not self.mapInstancer then				(					self.getMapLoaders inst:True					self.mapInstancer = True				)				self.ro.drawData self.ro.dgv_data self.mapLoaderArr nested:True				itm_instance.enabled = True			)			on itm_instance picked do			(				self.instanceLoaders data:self.mapLoaderArr				self.getMapLoaders inst:True				self.ro.drawData self.ro.dgv_data self.mapLoaderArr nested:True			)			on itm_removeMissing picked do			(				clearListener()				self.collectMaterials()				for i in self.materialList do				(					self.removeImageLoadersWithMissingFiles i				)				format "***** % files removed *****\n" self.missingFileCount				self.ro.refreshDataGrid self.ro.dgv_data			)			on itm_mapNames picked do			(				if queryBox "This will rename all map loaders to the filename they are loading\n\nContinue?" title:"GTVFX" then				(					self.renameMapLoadersToFileName loaderArr:self.mapLoaderArr					self.ro.refreshDataGrid self.ro.dgv_data				)			)			fn _init pself =			(				self = pself				itm_instance.enabled = False			)		)		rcm_uiBar	),    	fn UiDeps =	(		rollout ro_deps "Dependents" width:500		(			local self			fn _init pself =			(				self = pself			)		)		createDialog ro_deps		ro_deps._init self	),    	fn UiMapStats =	(		False	),    	fn UiProg =	(		rollout ro_prog "" width:500		(			local self			label lbl_prg "Drawing Data:" align:#left			progressBar prg_main color:orange			fn _init pself =			(				self = pself			)		)		createDialog ro_prog		ro_prog._init self	),    	fn Ui =	(		rollout ro "Map Inspector by GTVFX" width:850		(			local self			local tab = 1			local uiDic			local initSize			local rcm_UI			local dnToolTip			local clrWindow = ((colorMan.getColor #window)*255)			local clrText = ((colorMan.getColor #text)*255)			local ClrBackGround = ((colorMan.getColor #background)*255)			local tHeight = 12			local jpgClr = (dotnetClass "System.Drawing.Color").lightGreen			local exrClr = (dotnetClass "System.Drawing.Color").SkyBlue			local defClr = (dotnetClass "System.Drawing.Color").plum			local missingClr = (dotnetClass "System.Drawing.Color").tomato			local bmpClr = (dotnetClass "System.Drawing.Color").dodgerblue			local pngClr = (dotnetClass "System.Drawing.Color").fromARGB 252 145 27			local tgaClr = (dotnetClass "System.Drawing.Color").fromARGB 155 250 58			local txClr = (dotnetClass "System.Drawing.Color").lime			local psdClr = (dotnetClass "System.Drawing.Color").yellow            			checkBox chk_sMapName "Search By Map Name" across:2			checkBox chk_sFileName "Search By Filename" checked:True offset:[-250,0]			dotNetControl dNtxt_search "Textbox" height:20			dotNetControl dNlbl_stats "Label" width:200 height:20 offset:[0,10]			dotNetControl dgv_data "DataGridView" align:#left  height:400			hyperLink hyp_website "www.gtvfx.com" color:orange  hoverColor:red visitedColor:orange address:"http://www.gtvfx.com"			            fn NormalizeRGB val =			(				if val <0 then val = 0 else if val >255 then val = 255				val			)            			fn InitToolTip dNetObj caption =			(				if dnTooltip == undefined then				(					dnToolTip = dotnetobject "ToolTip"					dnToolTip.AutoPopDelay = 5000					dnToolTip.InitialDelay = 300					dnToolTip.ReshowDelay = 300					dnToolTip.ShowAlways = true					dnToolTip.IsBalloon = true				)				dnToolTip.SetToolTip dNetObj caption			)            			fn SetDotNetWidget dNobj caption fontSize colorOffsetInt:0 fontStyle:#bold foreColor:unsupplied =			(				fStyle = case fontStyle of				(					(#bold):					(						((dotNetClass "System.Drawing.FontStyle").bold)					)					(#italic):					(						((dotNetClass "System.Drawing.FontStyle").italic)					)					(#regular):					(						((dotNetClass "System.Drawing.FontStyle").regular)					)				)				dNobj.text = caption				if foreColor == unsupplied then dNobj.forecolor = dNobj.forecolor.FromArgb clrText.x clrText.y clrText.z else dNobj.forecolor = foreColor				dNobj.backColor = dNobj.backcolor.FromArgb (normalizeRGB (ClrBackGround.x+colorOffsetInt)) (normalizeRGB (ClrBackGround.y+colorOffsetInt)) (normalizeRGB (ClrBackGround.z+colorOffsetInt))				dNobj.Font = dotNetObject "System.Drawing.Font" "Tahoma" fontSize fStyle				dNobj.update()			)            			fn SetDataGridColor dgv fontSize =			(				dgv.forecolor = dgv.forecolor.FromArgb clrText.x clrText.y clrText.z				dgv.BackgroundColor = dgv.BackgroundColor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.DefaultCellStyle.BackColor = dgv.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				try(dgv.AlternatingRowsDefaultCellStyle.BackColor = dgv.AlternatingRowsDefaultCellStyle.BackColor.FromArgb (clrWindow.x-15) (clrWindow.y-15) (clrWindow.z-15))catch()			)            			fn InitTabs dNtab tabArr =			(				dNtab.controls.clear()				setDotNetWidget dNtab "" 11 colorOffsetInt:10				for r in tabArr do				(					tP = dotNetObject "System.Windows.Forms.TabPage"					setDotNetWidget tP r 11 colorOffsetInt:10					dNtab.controls.add tP				)				dNtab.update()			)            			fn InitDnetBtn dNbtn caption fontSize style:#popup colorOffsetInt:0 tooltip:"" =			(				case style of				(					#flat:(dNbtn.flatStyle = dNbtn.flatStyle.flat)					#popup:(dNbtn.flatStyle = dNbtn.flatStyle.popup)					#system:(dNbtn.flatStyle = dNbtn.flatStyle.system)				)				setDotNetWidget dNbtn caption fontSize colorOffsetInt:colorOffsetInt				initToolTip dNbtn tooltip				dNbtn.tag = tooltip				dNbtn.update()			)            			fn InitTxtBx tbx caption fontSize tooltip:"" =			(				tbx.backcolor = tbx.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				tbx.forecolor = tbx.forecolor.FromArgb clrText.x clrText.y clrText.z				tbx.text = caption				tbx.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				tbx.BorderStyle = (dotNetClass "System.Windows.Forms.BorderStyle").FixedSingle				tbx.MultiLine = false				tbx.AcceptsReturn = false				tbx.AcceptsTab = false				tbx.WordWrap = false				initToolTip tbx tooltip				tbx.update()			)            			fn InitDnetLbl lbl caption fontsize fontStyle:#bold foreColor:unsupplied =			(				setDotNetWidget lbl caption fontSize fontStyle:fontStyle foreColor:foreColor			)            			fn ChangeDgvCellColor dgvCell color =			(				newStyle = dotNetObject "System.Windows.Forms.DataGridViewCellStyle"				newStyle.foreColor = color				dgvCell.Style = newStyle			)            			fn DrawData dgv dataArr nested:False =			(				dgv.rows.clear()				self.uiProg()				perc = (100.0 / dataArr.count)				percentu = perc				for a in dataArr do				(					tempRow = dotNetObject "System.Windows.Forms.DataGridViewRow"					dgv.rows.add tempRow					bMap = undefined					case nested of					(						(True):						(							bMap = a[1]						)						default:						(							bMap = a						)					)					mFileName = (self.getMapLoaderFileName bMap)					type =try(tolower(getFileNameType mFileName))catch("<NA>")					exists = if type != "<NA>" then doesFileExist mFileName else False					count = (if nested then a.count-1 else "?")					tempRow.SetValues #(bMap.name, count, mFileName, type, (classOf bMap as string))					if exists then					(						case type of						(							".jpg":							(								tempRow.DefaultCellStyle.ForeColor = jpgClr							)							".exr":							(								tempRow.DefaultCellStyle.ForeColor = exrClr							)							".png":							(								tempRow.DefaultCellStyle.ForeColor = pngClr							)							".bmp":							(								tempRow.DefaultCellStyle.ForeColor = bmpClr							)							".psd":							(								tempRow.DefaultCellStyle.ForeColor = psdClr							)							".tx":							(								tempRow.DefaultCellStyle.ForeColor = txClr							)							".tga":							(								tempRow.DefaultCellStyle.ForeColor = tgaClr							)							default:							(								tempRow.DefaultCellStyle.ForeColor = defClr							)						)					)					else					(						tempRow.DefaultCellStyle.ForeColor = missingClr					)					self.ro_prog.prg_main.value = percentu					percentu += perc				)				for c = 0 to (dgv.columns.count-1) do				(					case c of					(						2:						(							dgv.columns.item[c].autoSizeMode = dgv.columns.item[c].autoSizeMode.fill						)						default:						(							dgv.columns.item[c].autoSizeMode = dgv.columns.item[c].autoSizeMode.DisplayedCells						)					)				)				dgv.sort dgv.columns.item[(dgv.columns.count-2)] (dotNetClass "System.ComponentModel.ListSortDirection").ascending				dgv.clearSelection()				dgv.update()				self.ro_prog.prg_main.value = 100				destroyDialog self.ro_prog			)            			fn InitDgv dgv fontsize colAr tooltip:"" =			(				dgv.Columns.Clear()				dgv.MultiSelect = True				dgv.AllowUserToAddRows = off				dgv.AutoSize = on				dgv.AutoSizeColumnsMode = dgv.AutoSizeColumnsMode.Fill				dgv.ShowEditingIcon = dgv.RowHeadersVisible = off				dnSelectionMode = dotNetClass "System.Windows.Forms.DataGridViewSelectionMode"				dgv.SelectionMode = dnSelectionMode.FullRowSelect				dgv.AllowUserToResizeRows = False				dgv.AllowUserToOrderColumns = False				dgv.AllowUserToResizeColumns = True				dgv.ColumnHeadersHeightSizeMode = dgv.ColumnHeadersHeightSizeMode.DisableResizing				for col in colAr do				(					dnNewColumn					case col[1] of					(						(#Text):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewTextBoxColumn"						(#Bool):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewCheckBoxColumn"						default:dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewComboBoxColumn"					)					dnNewColumn.HeaderText = col[2]					dnNewColumn.ReadOnly = col[3]					dnAlignment = dotNetClass "System.Windows.Forms.DataGridViewContentAlignment"					case col[4] of					(						#Right:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleRight						#Center:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleCenter						#Left:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft						default:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft					)					dgv.columns.add dnNewColumn				)				setDataGridColor dgv fontSize				for c = 0 to (colAr.count-1) do				(					dgv.columns.item[c].sortMode = (dotNetClass "System.Windows.Forms.DataGridViewColumnSortMode").automatic				)				initToolTip dgv tooltip				dgv.update()			)            			fn UpdatedStats =			(				dNlbl_stats.text = ("Map loaders in scene:  " + (self.loaderCount as string))			)            			fn RefreshDataGrid dgv pForce:False =			(				colArr = #()				append colArr #(#Text,"Map Name",True,#left)				append colArr #(#Text, "Dups",True,#center)				append colArr #(#Text, "Filename",True,#left)				append colArr #(#Text,"Format",True,#center)				append colArr #(#Text,"Loader Type",True,#center)				initDgv dgv 10 colArr				if self.mapLoaderArr.count == 0 or pForce then				(					self.getMapLoaders()				)				drawData dgv self.mapLoaderArr nested:self.mapInstancer				updatedStats()			)            			fn PosHyperLink posX posY =			(				hyp_website.pos = [posX,posY]			)            			fn GetDgvCellValue dgv rowIndex cellIndex =			(				out = dgv.rows.item[rowIndex].cells.item[cellIndex].value				out			)            			fn UiMenu =			(				rcmenu rcm_UI				(					local self					menuItem itm_viewSelected "View Image"					separator sep_1a					menuItem itm_putToMedit "Put To Medit"					separator sep_1b					menuItem itm_removeSel "Destroy Selected"					separator sep_1c					menuItem itm_getStats "Show File Stats"					on itm_viewSelected picked do					(						selRows = dgv_data.selectedRows						if selRows.count != 1 then return messageBox "This only works on single row selection" title:"GTVFX:"						fileName = selRows.item[0].cells.item[2].value						if doesFileExist fileName then						(							bMap = (self.getMapLoadersByFileName fileName)[1]							if bMap != undefined then							(								self.ViewMap bMap							)							else							(								messageBox "Could not find map loader..." title:"GTVFX:"							)						)						else						(							messageBox "File does not exist..." title:"GTVFX:"						)					)					on itm_putToMedit picked do					(						selRows = dgv_data.selectedRows						if selRows.count != 1 then return messageBox "This only works on single row selection" title:"GTVFX:"						mapName = selRows.item[0].cells.item[0].value						bMap = (self.getMapLoaderByName mapName)[1]						if bMap != undefined then						(							meditMaterials[activeMeditSlot] = bMap						)						else						(							messageBox "Could not find map loader..." title:"GTVFX:"						)					)					on itm_removeSel picked do					(						selRows = dgv_data.selectedRows						progressStart "Removing maps:"						perc = (100.0 / (selRows.count))						percentu = perc						for i = 0 to (selRows.count-1) do						(							loaderName = selRows.item[i].cells.item[0].value							bMaps = self.getMapLoaderByName loaderName							for bMap in bMaps do							(								self.removeBitmapSubs bMap							)							progressUpdate percentu							percentu += perc						)						progressEnd()						self.ro.refreshDataGrid self.ro.dgv_data pForce:True					)					on itm_getStats picked do					(						format "***** Get Stats *****\n"						/*						selRows = dgv_data.selectedRows						deps = collectDependentNodes selRows						clearSelection()						if deps.count != 0 then select deps else messageBox "No Dependencies\nIf your selection is a textureMap then this is just a map floating in a material editor slot" title:"GTVFX:"						 */					)					fn _init pself =					(						self = pself					)				)				rcm_UI			)            			fn _init pself =			(				self = pself				initTxtBx dNtxt_search "Search" 12 tooltip:"Filter rows\nDouble-Click to clear contents"				initDnetLbl dNlbl_stats "Map loaders in scene:" 9 fontStyle:#regular foreColor:((dotnetClass "System.Drawing.Color").fromARGB 255 127.5 0)				refreshDataGrid dgv_data			)            			fn FilterDataGridRows dgv cellIndex filterTxt = -- function for the search feature			(				if filterTxt == "" or filterTxt == "Search" then				(					for i in 0 to dgv.rows.count-1 do					(						dgv.rows.item[i].visible = true					)				)				else				(					for i in 0 to dgv.rows.count-1 do					(						if not matchPattern dgv.rows.item[i].cells.item[cellIndex].value pattern:("*"+filterTxt+"*") then						(							dgv.rows.item[i].visible = false						)						else						(							dgv.rows.item[i].visible = true						)					)				)			)            			fn GetUiControlName uiControl =			(				str = (uiControl as string)				uiName = (filterString str ":")[2]				uiName			)            			fn GetControlByName controlName =			(				out = (for i in self.ro.controls where matchPattern (i as string) pattern:("*:"+controlName+"*") collect i)[1]				out			)            			fn CollectUiControls =			(				dic = dotNetObject "System.Collections.Hashtable"				subDic = dotNetObject "System.Collections.Hashtable"				subDic.add "width" ro.width				subDic.add "height" ro.height				dic.add "ui" subDic				for c in ro.controls where (isproperty c #width) and (isproperty c #height) do				(					subDic = dotNetObject "System.Collections.Hashtable"					subDic.add "width" c.width					subDic.add "height" c.height					subDic.add "pos.x" c.pos.x					subDic.add "pos.y" c.pos.y					dic.add (getUiControlName c) subDic				)				dic			)            			fn ResizeUI val =			(				dif = (val - initSize)				offMult = 1				c = getControlByName "dNtxt_search"				c.width = (uiDic.item["dNtxt_search"].item["width"] + dif.x)				c = getControlByName "dgv_data"				c.width = (uiDic.item["dgv_data"].item["width"] + dif.x)				c.height = (uiDic.item["dgv_data"].item["height"] + (dif.y*offMult))				posHyperLink (self.ro.width/2-40) (self.ro.height - 20)			)            			on chk_sMapName changed state do			(				chk_sFileName.state = not state			)            			on chk_sFileName changed state do			(				chk_sMapName.state = not state			)            			on dgv_data mouseDown arg do			(				if arg.button == dgv_data.mouseButtons.right then				(					popUpMenu (uiMenu()) pos:mouse.screenPos					rcm_UI._init self				)			)            			on dNtxt_search keyUp arg do			(				indx = 2				if chk_sMapName.state then indx = 0				filterDataGridRows dgv_data indx dNtxt_search.text			)            			on dNtxt_search MouseDoubleClick arg do			(				dNtxt_search.text = ""				for i in 0 to dgv_data.rows.count-1 do				(					dgv_data.rows.item[i].visible = true				)			)            			on dNtxt_search MouseClick arg do			(				if dNtxt_search.text == "Search" then dNtxt_search.text = ""			)            			on ro open do			(				posHyperLink (ro.width/2-40) (ro.height - 20)				initSize = [ro.width,ro.height]				uiDic = collectUiControls()			)            			on ro close do			(				if self.storedMaterial != undefined then meditMaterials[24] = self.storedMaterial			)            			on ro help do			(				format "***** Coming Soon *****\n"			)            			on ro resized val do			(				resizeUI val			)		)        		createDialog ro menu:(this.menuBar()) style:#(#style_titlebar, #style_resizing, #style_sunkenedge, #style_sysmenu, #style_minimizebox, #style_maximizebox)		ro._init this		rcm_uiBar._init this	),        private fn __init__ =	(		-- Pass	),		init = __init__())MapInstancer = MapInstancer()