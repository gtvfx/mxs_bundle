/***************************************************************************************************Copyright (C) 2013 - 2017  Gavyn ThompsonThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation; either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program. if not, see <http://www.gnu.org/licenses/>.***************************************************************************************************//***************************************************************************************************Author:				    Gavyn ThompsonCompany:				GTVFXWebsite:				https://github.com/gtvfxEmail:				    gftvfx@gmail.comScriptVersion:			Updated:				***************************************************************************************************//*__HELP__Constructor: Instantiated Global: [METHODS][DESCRIPTION][USAGE]__END__*/mxs.Using "DotNetUi"try(destroyDialog _sceneSanity.ro)catch()::_sceneSanity = undefinedstruct qcPlugin(	/* 	Construct for plugin object	 */	title = "",	method = unsupplied,	aux = unsupplied,	active = False,	description = "")struct qcPluginManager(	/* 	The Plugin manager is inherited by the main tool and handles the plugins	 */		_resourcePath, -- Path to folder containing plugin files	_pluginsLoaded = False,	_plugins = #(), -- Array of qcPlugin objects		fn Register title:unsupplied method:unsupplied aux:unsupplied active:true description:"" =	( 		local success = True				if title == unsupplied or method == unsupplied then		(			format "***** Plugin Load Failed *****\n"			return False		)				format "***** Loading Plugin: % *****\n" title		append this._plugins ( qcPlugin title:title method:method aux:aux active:active description:description )	),		fn init refresh:false =	(		if (not this._pluginsLoaded or refresh) then		(			-- Load Plugins			format "--------------------------------------------------------------------------------------------------------------\n"			format "===== Loading Plugins... =====\n"						this._plugins = #()						-- Load Plugin Files			local filenames = getFiles (_resourcePath + "*.ms")						for filename in filenames do ( filein filename )						format "--------------------------------------------------------------------------------------------------------------\n"						-- Load State from INI			--this.loadCustomState()		)	))struct _sceneSanityCheck(	self,	ro,	rootHelper,	msgBuffer = (StringStream ""),	tstMsg = #(),	pluginList = #(#Sanity_DuplicateNames),	---test reslut object arrays	testResults = #(),	testPluginArr = #(),	testFnArr = #(),	testAuxFn = #(),	showUi = True,		--	resourcePath = ( (_mxsLib.GetLibPath()) + "/scriptPlugins/SceneSanityChecks/" ),	plugManager = undefined,			fn RemoveInvalidChars str =	(		charArr = #(".","!","@","#","$","%","^","&","*",";",":",",","?","|","/","\\","\"","'"," ")		for i in charArr do		(			str = SubstituteString str i ""		)		(str as string)	),			fn RegisterTestCheck pluginObj =	(		/* 		Adds a plugin object to a local level array		 */		append this.testPluginArr pluginObj	),		fn RegisterTestsCode =	(		/* 		Creates the final local level array of plugin objects to be used		 */		if this.plugManager._plugins.count != 0 then		(			for p in this.plugManager._plugins do			(				this.registerTestCheck p			)		)	),		fn RunTest ro:undefined =	(		/* 		Runs the .method property of each loaded plugin and supplies a message back to the UI with the test result		 */				local pass = true				if this.testResults.count == 0 then		(			this.testResults = for i = 1 to this.testPluginArr.count collect false			this.tstMsg = for i = 1 to this.testPluginArr.count collect "none"		)				local nmbTestRan = 0				for i = 1 to this.testPluginArr.count do		(			if this.testResults[i] then continue -- if we passed this test before early out..							nmbTestRan += 1						local Test = this.testPluginArr[i].method						--format "***** Test: % *****\n" test			local subItem						if this.ro != undefined then			(				subItem = this.ro.dgv_test.rows.item[i-1].cells.item[1]				subItem.value = "Running..."				this.ro.dgv_test.update()				sleep .1			)						case ( Test() ) of			(				(True):				(					if subItem != undefined then					(						subItem.value = "Passed"						tstMsg[i] =  "Passed"						_dotNet.ChangeDgvCellColor subItem _dotNet.clr_text					)										this.testResults[i] = true				)				default:				(					if subitem != undefined then					(						this.tstMsg[i] = (this.msgBuffer as string)						subitem.value = "Failed"						_dotNet.ChangeDgvCellColor subItem _dotNet.clr_errorRed					)										this.testResults[i] = false										pass = false				)			)		)				if this.ro != undefined then ro.dgv_test.update()		format "Number of Test's Run %\n" nmbTestRan		pass	),		-------------ui stuff...	fn Ui =	(		rollout ro "ILM Scene Sanity Checks" width:500		(			local self			local uiDic			local initSize			local rcm_test			local tests			local success = false						dotNetControl dgv_test "DataGridView" height:10			dotNetControl dNlbl_msg "Label" width:(ro.width-25) height:20			dotNetControl dNbtn_run "Button" width:(ro.width-25) height:40						--			fn DrawData dgv dataArr =			(				/* Tells the UI how to display the data */				rowSize = 26.75								for i in 0 to dgv.columns.count-1 do				(					dgv.Columns.item[i].SortMode = (dotNetClass "System.Windows.Forms.DataGridViewColumnSortMode").NotSortable				)				dgv.rows.clear()				for d in dataArr do				(					tName = d.title --substituteString (d as string) "()" ""					tempRow = dotNetObject "System.Windows.Forms.DataGridViewRow"					dgv.rows.add tempRow					tempRow.SetValues #(tName, "idle")					dgv.height += rowSize-2				)				ro.height += dgv.height				dgv.columns.item[0].autoSizeMode = dgv.columns.item[0].autoSizeMode.Fill				dgv.columns.item[1].autoSizeMode = dgv.columns.item[1].autoSizeMode.DisplayedCells				dgv.clearSelection()				dgv.update()			)						fn RcMenuUi funcIndx =			(				/* 				RC Menu programatically created on the fly based on plugin data				 */								funcAr = self.testPluginArr[funcIndx].aux								if funcAr.count == 0 then				(					rcmenu rcm_test					(						menuitem testA "no auxiliary functions have been registered for this test..."						fn _init pself =						(							self = pself						)					)				)				else				(					rcTxt = stringStream ""					st = "rcmenu rcm_test\n(%\n%\n%\n%\n)"					vars = "\n\tlocal self\n\tlocal pluginObj\n" 					items = ""					events = ""					cb = stringStream ""					format "\tfn _init pself =\n\t(\n\t\tself = pself\n\t\tpluginObj = self.testPluginArr[%]\n\t)" funcIndx to:cb					cb = cb as string					-- build items					for f = 1 to funcAr.count do					(						------items						fName = substituteString (self.testPluginArr[funcIndx].aux[f] as string) "()" ""						itemName = (self.RemoveInvalidChars fName)						it = "" as stringstream						format "\tmenuItem %_item \"%\"\n" itemName fName to:it						items += it as string						--events						ev = "" as stringStream						if not (matchPattern fname pattern:"select*") then						(							format "\ton %_item picked do\n\t(\n\t\tpluginObj.aux[%]()\n\t\tself.runTest ro:self.ro\n\t)\n" itemName f to:ev						)						else						(							format "\ton %_item picked do (pluginObj.aux[%]())\n" itemName f to:ev						)						events += ev as string					)					format st vars items events cb to:rcTxt										--format "====== RC Menu =====\n"					--format "%\n" rcTxt										rcm_test = execute (rcTxt as string)				)				rcm_test			)						fn UpdateTestMessage rowIndex =			(				index = (rowIndex + 1)				if self.tstMsg[index] != undefined then				(					dNlbl_msg.text = "Test Messages: "+self.tstMsg[index]				)				else				(					dNlbl_msg.text  = "Test Messages: <idle>"				)			)						fn ResizeUI val =			(				dif = (val - initSize)				offMult = 1 -- across value of ui controlls. 3 = 0.3333333, 2 = 0.6666666								c = _dotNet.GetControlByName ro "dgv_test"				c.width = (uiDic.item["dgv_test"].item["width"] + dif.x)				c.height = (uiDic.item["dgv_test"].item["height"] + (dif.y*offMult))									c = _dotNet.GetControlByName ro "dNlbl_msg"				c.width = (uiDic.item["dNlbl_msg"].item["width"] + dif.x)				c.pos = [uiDic.item["dNlbl_msg"].item["pos.x"],(uiDic.item["dNlbl_msg"].item["pos.y"] + (dif.y*offMult))]								c = _dotNet.GetControlByName ro "dNbtn_run"				c.width = (uiDic.item["dNbtn_run"].item["width"] + dif.x)				c.pos = [uiDic.item["dNbtn_run"].item["pos.x"],(uiDic.item["dNbtn_run"].item["pos.y"] + (dif.y*offMult))]			)						fn GetColArr =			(				colArr = #()				append colArr #(#text,"Test:",True,#left)				append colArr #(#text,"Result:",True,#left)				colArr			)						fn _init pself =			(				self = pself				_dotNet.initDnetBtn dNbtn_run "Rerun Failed Tests" 11 style:#popup colorOffsetInt:10 tooltip:""								_dotNet.InitDgv dgv_test 10 (GetColArr()) multiSelct:False								drawData dgv_test self.testPluginArr colArr:colArr									_dotNet.initDnetLbl dNlbl_msg caption:"Test Messages: <idle>" fontSize:9								success = self.runTest ro:ro			)						on lv_test itemSelectionChanged x do			(				item = x.item				if self.tstMsg[item.index + 1] != undefined then errLbl.text = "Test Messages:"+self.tstMsg[item.index + 1] else errLbl.text  = "Test Messages:Idle"			)						on dgv_test mouseDown args do			(				hit = dgv_test.hitTest args.location.x args.location.y				if hit.type != hit.type.cell then return False				clickedRow = dgv_test.rows.item[hit.RowIndex]				clickedCell = clickedRow.Cells.item[hit.ColumnIndex]				case (args.button) of				(					(dgv_test.mouseButtons.left):					(						updateTestMessage hit.RowIndex					)					(dgv_test.mouseButtons.right):					(						clickedRow.selected = true						updateTestMessage hit.RowIndex						m = rcMenuUi (hit.RowIndex+1)						popUpMenu m pos:mouse.screenPos						rcm_test._init self					)				)			)						on dNbtn_run mouseClick do			(				if (querybox "Would you like to rerun the tests?") then self.runTest ro:ro			)						on ro open do 			(				initSize = [ro.width,ro.height]				uiDic = _dotNet.GetUiControlDic ro			)						on ro resized val do			(				resizeUI val			)		)		createDialog ro		ro._init self	),		fn Run =	(		-- Running the tool in Modal mode prevents any resizing. Do not run this tool in Modal mode		this.Ui()	),		fn _init =	(		format " <idle>\n" to:this.msgBuffer		format "_sceneSanity: % \n" _sceneSanity		self = this				this.plugManager = ::qcPluginManager _resourcePath:this.resourcePath		this.plugManager.init()				this.RegisterTestsCode()				if this.showUi then this.Run()				True	))::_sceneSanity = _sceneSanityCheck()-- We have to initialze post instantiation in order to aggregate the class object through the global variable to the plugin objects::_sceneSanity._init()