/***********************************************************************************************Extendable tab menu architecture by Gavyn ThompsonThis tool is populated by parsing a system directory supplied by the masterShelfDir variableThe tool is easily extenedable through the system directory***********************************************************************************************/try(cui.unRegisterDialogBar TabMenu.ro)catch()try(destroyDialog TabMenu.ro)catch()mxs.Using "DotNetUi"mxs.Using "HashTableMethods"struct TabMenu(	ro,	showUi = False,	tabArr = #(),	toolsDic, -- Cached dictionary for all tools	tabDirs = #(),	tabIni = ( ( GetDir #plugcfg ) + "\\mxs_tabMenu.ini" ),	iconPrefix = "tabMenu_",	userTabName = "MyTab",		masterShelfDir = ( ( GetFileNamePath ( GetSourceFileName() ) ) + ( GetFileNameFile ( GetSourceFileName() ) ) + "_resource\\" ),	allShelvesDir = ( this.masterShelfDir + @"\AllShelves\" ),	resourceDir = ( this.masterShelfDir + @"_resource\" ),	userDir,        rgx_prefix = dotnetobject "System.Text.RegularExpressions.Regex" "[0-9_]",        _enabled = True,	    fn RunTool scriptFile =    (        if this._enabled then        (            FileIn scriptFile        )        else        (            format "***** Tab Menu Disabled *****\n"        )    ),		fn PrintDnetDic hash =	( 		DNArray = dotNetObject "System.string[]" hash.keys.count		hash.keys.copyTo DNArray 0		for i = 0 to (hash.keys.count-1) do		(			itemStr = (DNArray.get i)			format "% = %\n" itemStr hash.item[itemStr]		)	),		fn CollectDicKeys dic =	(		/* 		Collects all of the keys of a dictionary as an array of their string values.		You can use this to loop through each key		 */		arr = #()		dNarr = dotNetObject "System.string[]" dic.keys.count		dic.keys.copyTo dNarr 0		for i = 0 to (dic.keys.count-1) do		(			append arr (dNarr.get i)		)		arr	),		fn TabMenuEnabled state =    (       this._enabled = state    ),    	fn TrimNumericPrefix str =	(		/*                     Trims the numeric prefix e.g. "00_" from the folder name.                    The numeric prefix is used to put the tools in a specific order on the menu                */                local out = str        		for i = 1 to str.count do		(                        if not ( this.rgx_prefix.IsMatch str[i] ) then exit                        out = ( SubstituteString out str[i] "" )		)                out	),		fn GetUserDir =	( -- Gets the user-specific folder for the "MyTab" menu		this.userDir = ( ( ::mxs.GetUserDir env:#local ) + "\\" + this.userTabName + "\\")		if not doesFileExist userDir then makeDir this.userDir		this.userDir	),		fn RoboCopy sourceDir destDir arg:"/MIR" hidden:True= -- MIR mirrors the directories contents	( -- Simple method to use RoboCopy        local command = undefined		case hidden of		(			(True):( command = HiddenDosCommand )			(False):( command = DosCommand )		)                if ( command != undefined ) then command ("robocopy "+sourceDir+" "+destDir+" "+arg)	),		fn CreateUserDir =	( -- Make the user directory and copy over the premade tools from the _resource		if ( this.GetUserDir() ) != undefined then        (            makeDir ( this.userDir + @"00_OpenMyTabDir" )            makeDir ( this.userDir + @"01_CreateMyTabEntry" )            this.RoboCopy ( this.resourceDir + @"00_OpenMyTabDir\" ) ( this.userDir + @"00_OpenMyTabDir\" ) arg:"/MIR"            this.RoboCopy ( this.resourceDir + @"01_CreateMyTabEntry\" ) ( this.userDir + @"01_CreateMyTabEntry\" ) arg:"/MIR"        )            		else        (            messageBox "Unable to get User Dir" title:"Error:"        )	),		fn CollectTabDirs exemptArr:#("AllShelves", "_resource") =	(        /*                     Collects all the directories in the masterShelfDir                    Skips any directories in the exemptArr                */		this.tabDirs = sort ( GetDirectories ( this.masterShelfDir + "*" ) )        		if ( this.GetUserDir() ) != undefined then this.tabDirs += #( this.GetUserDir() )        --if ( this.GetShowDir() ) != undefined then this.tabDirs += #( this.GetShowDir() )        		this.tabArr = #()        		for dir in tabDirs do		(			local fArr = ( filterString dir "\\" )            local tabName = fArr[fArr.count]            			if ( findItem exemptArr tabName != 0 ) then continue            			append this.tabArr ( this.TrimNumericPrefix ( tabName ) )		)        		this.tabArr	),		fn ClearIconCache =	(		/*                     Clears any previously stored icons                */		local fArr = GetFiles ( ( GetDir #userIcons ) + "\\" + iconPrefix + "*" )		for i in fArr do deleteFile i	),    	fn CacheIcon image =	(        /*                     Copies the icon file to the local machine with a new prefix                    deletes old files if they exist                                        We do this because DotNet latches on to the icon files and does not allow us to update them as long as someone has them referenced                    So you cannot delete or change icons if you leave them referenced from the server.                */		local newPath = ( ( GetDir #userIcons ) + "\\" + iconPrefix + ( FileNameFromPath image ) )		if (doesFileExist newPath) then deleteFile newPath		copyFile image newPath		newPath	),        fn IsImageFile filePath =    (        ::PYTHON_RETURN = undefined                local pyCmd = StringStream ""                format "import imghdr        mxsReturn = FalsefileType = imghdr.what(r'%')if fileType:    mxsReturn = TrueMaxPlus.Core.EvalMAXScript('PYTHON_RETURN = \"{0}\"'.format(mxsReturn))        " filePath to:pyCmd                python.execute ( pyCmd as string )                ( ::PYTHON_RETURN as BooleanClass )    ),    	fn CollectImageFiles dir extArr:#(".bmp",".png",".jpg")=	(		/*                     Collects all image files of supported format for icons in the supplied directory                */        local out = #()        local fArr = GetFiles (dir + "\\*")                for file in fArr do        (            try            (                if ( this.IsImageFile file ) then                (                    append out file                )            )            catch            (                if ( findItem extArr ( GetFileNameType file ) != 0 ) then                (                    append out file                )            )        )				out	),    	fn GetTooltip dir =	(		/*                     Finds the tooltip.txt in the supplied directory                    Reads the contents of the file into a string which is returned                */		local tFile = ( GetFiles ( dir + "\\*tooltip.txt" ) )[1]		if tFile == undefined then return undefined            		local tTip = stringStream ""        format ( ( substituteString ( this.TrimNumericPrefix ( fileNameFromPath dir ) ) "\\" "" ) + "\n" ) to:tTip        		local strm = openFile tFile mode:"r"                try        (            while not ( eof strm ) do            (                local l = readLine strm                format "%\n" l to:tTip            )                        close strm        )        catch        (            close strm        )        		( tTip as string )	),    	fn CollectTools dir fTypes:#(".ms",".mse",".mzp")=	(		/*                     Collects all the sub-directories of the supplied dir and builds a dictionary for each tool it finds                */        		local dic = dotNetObject "System.Collections.Hashtable"		local dirArr = GetDirectories ( dir + "*" )        		for d in dirArr do		(			local sFile = undefined			local bFile = undefined			local tTip = this.GetTooltip d			local fName = filenameFromPath d						if ( MatchPattern fName pattern:"* *" ) then			(				format "Warning... tool \"%\" can not be loaded becuse there are spaces in the name.....\n" d				continue			)            			local mxScripts = #()            			for f in fTypes do			(				mxScripts += ( GetFiles (d+"*"+f) )			)                        if mxScripts.count != 0 then sFile = mxScripts[1] else continue            			local bMaps = this.CollectImageFiles d            			if bMaps.count != 0 then bFile = ( this.CacheIcon bMaps[1] ) else bFile = undefined            			local subDic = dotNetObject "System.Collections.Hashtable"			subDic.add "name" ( SubstituteString ( this.TrimNumericPrefix fName ) "\\" "" )			subDic.add "sFile" sFile			subDic.add "icon" bFile			subDic.add "tooltip" tTip            			dic.add ( fName ) subDic		)        		dic	),    	fn BuildToolsDic =	(		/*                     Builds the main dictionary used to populate the menu                */		this.toolsDic = dotNetObject "System.Collections.Hashtable"        		for tab in this.tabDirs do		(            local tabName = ( SubstituteString ( this.trimNumericPrefix ( filenameFromPath tab ) ) "\\" "" )            			this.toolsDic.add tabName ( this.CollectTools tab )		)        		this.toolsDic	),		fn ui =	(		rollout ro "MXS Tab Menu" width:1200		(			local self			local dnToolTip			local tabDic			local rcm_UI			local clrWindow = ((colorMan.getColor #window)*255)			local clrText = ((colorMan.getColor #text)*255)			local clrBackGround = ((colorMan.getColor #background)*255)			local tHeight = 9			local tabArr = #()						dotNetControl dNtab_switch "TabControl" height:20 offset:[0,-6]			dotNetControl dgv_tools	"DataGridView" height:25 offset:[0,-4]						fn GetScreenResolution =			(				/*                                     Get the screen resolution to determine the width of the toolbar                                */				local scr = ( dotNetClass "System.Windows.Forms.Screen" ).PrimaryScreen.Bounds				[scr.Width, scr.Height]			)            			fn SetDataGridColor dgv fontSize =			(				-- Try()Catch() implemented to prevent UI crashing when DotNet trys to add duplicate entries into object dictionaries when rebuilding the UI.				try				(					dgv.forecolor = dgv.forecolor.FromArgb clrText.x clrText.y clrText.z					dgv.BackgroundColor = dgv.BackgroundColor.FromArgb ClrBackGround.x ClrBackGround.y ClrBackGround.z					dgv.DefaultCellStyle.BackColor = dgv.BackgroundColor --dgv.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z					dgv.defaultCellStyle.SelectionBackColor = (DotNetClass "System.Drawing.Color").fromARGB 79 113 147					dgv.GridColor = dgv.BackgroundColor -- (DotNetClass "System.Drawing.Color").fromARGB 6 75 191					dgv.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").regular)				)				catch()			)            			fn InitDgv dgv fontsize colArr:#() =			(                local dnSelectionMode = dotNetClass "System.Windows.Forms.DataGridViewSelectionMode"                				dgv.ShowCellToolTips = False				dgv.MultiSelect = False				dgv.AllowUserToAddRows = off				dgv.AutoSize = on				dgv.ShowEditingIcon = dgv.RowHeadersVisible = off				dgv.ColumnHeadersVisible = False				dgv.SelectionMode = dnSelectionMode.CellSelect 				dgv.AllowUserToResizeRows = false				dgv.AllowUserToOrderColumns = false				dgv.AllowUserToResizeColumns = false				dgv.ColumnHeadersHeightSizeMode = dgv.ColumnHeadersHeightSizeMode.DisableResizing                				SetDataGridColor dgv fontSize				dgv.update()			)            			fn BuildDgvColumns dic =			(				local arr = #()				local kArr = self.collectDicKeys dic				sort kArr								for i = 1 to (dic.keys.count) do				(					case (dic.item[kArr[i]].item["icon"]) of					(						(undefined):						(							append arr #(#Text,"",True,#Center,dic.item[(kArr[i])])						)						default:						(							append arr #(#Icon,"",True,#Center,dic.item[(kArr[i])])						)					)				)								arr			)						fn BuildColArr dic =			(				local colArr = #()				colArr += buildDgvColumns self.toolsDic.item["AllShelves"]				colArr += buildDgvColumns dic				colArr 			)						fn DrawData dgv colArr:#() =			(				dgv.rows.clear()				dgv.columns.clear()								for col in colArr do				(					dnNewColumn					case col[1] of					(						(#Text):						(							dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewTextBoxColumn"						)						default:						(							dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewImageColumn"							dnNewColumn.image = (dotNetClass "System.Drawing.Bitmap").fromFile (col[5].item["icon"])						)					)					dnNewColumn.HeaderText = col[2]					dnNewColumn.ReadOnly = col[3]					dnAlignment = dotNetClass "System.Windows.Forms.DataGridViewContentAlignment"					case col[4] of					(						#Right:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleRight						#Center:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleCenter						#Left:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft						default:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft					)					dgv.columns.add dnNewColumn				)								tempRow = dotNetObject "System.Windows.Forms.DataGridViewRow"				dgv.rows.add tempRow								for i = 0 to (colArr.count-1) do				(					sFile = colArr[i+1][5].item["sFile"]					if isProperty dgv.columns.item[i] "Image" then					(						tempRow.cells.item[i].value = dgv.columns.item[i].image					)					else					(						tempRow.cells.item[i].value = (colArr[i+1][5].item["name"])					)					tempRow.cells.item[i].tag = sFile					--tTip = (colArr[i+1][5].item["tooltip"])					--if tTip == undefined then tTip = (colArr[i+1][5].item["name"])					--tempRow.cells.item[i].ToolTipText = tTip					case colArr[i+1][1] of					(						(#Text):						(							dgv.columns.item[i].autoSizeMode = dgv.columns.item[i].autoSizeMode.DisplayedCells						)						default:						(							dgv.columns.item[i].autoSizeMode = dgv.columns.item[i].autoSizeMode.NotSet							dgv.columns.item[i].width = 32						)					)				)				dgv.update()			)						fn RefreshDataGrid dgv tab:"Modleing" =			(				tabDic = ( BuildColArr self.toolsDic.item[tab] )				DrawData dgv_tools colArr:tabDic			)						fn uiMenu =			(				rcmenu rcm_UI				(					local self										subMenu "UI Options:"					(						menuItem itm_dockTop "Dock Top"						menuItem itm_dockBottom "Dock Bottom"						--menuItem itm_close "Remove Tab Menu"					)					separator sep_1a										on itm_dockTop picked do					(						if self.ro != undefined then						(							ini_DockState = try(cui.getDockState self.ro)catch(undefined)							if ini_DockState == #cui_dock_top then return True							cui.DockDialogBar self.ro #cui_dock_top							setIniSetting self.tabIni "UI" "DockState" "cui_dock_top"							itm_dockTop.checked = True							itm_dockBottom.checked = False						)						else messageBox "Could not detect the Toolbox Floater.\nMake sure the floater is initialized."					)					on itm_dockBottom picked do					(						if self.ro != undefined then						(							ini_DockState = try(cui.getDockState self.ro)catch(undefined)							if ini_DockState == #cui_dock_bottom then return True							cui.DockDialogBar self.ro #cui_dock_bottom							setIniSetting self.tabIni "UI" "DockState" "cui_dock_bottom"							itm_dockTop.checked = False							itm_dockBottom.checked = True						)						else messageBox "Could not detect the Toolbox Floater.\nMake sure the floater is initialized."					)					/* 					on itm_close picked do					(						setIniSetting self.tabIni "UI" "DockState" "Close"						try(cui.unRegisterDialogBar _tabMenu.ro)catch()						try(destroyDialog _tabMenu.ro)catch()					)					 */					fn _init pself =					(						self = pself					)				)				rcm_UI			)						fn SpawnRcMenu =            (                rcm_UI = UiMenu()                rcm_UI._init self                popUpMenu rcm_UI pos:mouse.screenPos                rcm_UI._init self            )            			fn _init pself =			(				self = pself				self.CreateUserDir()				::DotNetUI.InitTabs dNtab_switch ( self.CollectTabDirs() )				InitDgv dgv_tools tHeight				self.BuildToolsDic()				RefreshDataGrid dgv_tools tab:dNtab_switch.selectedTab.text			)            			on ro rightclick do			(				SpawnRcMenu()			)						on ro rightclick do			(				print "right click"			)						on ro open do			(				local scrX = ( GetScreenResolution() ).x				ro.width = ( scrX-10 )				dNtab_switch.width = (scrX-20)				dgv_tools.width = ( ro.width-13 ) 			)						on dgv_tools MouseClick args do			(				if args.button == dgv_tools.mouseButtons.right then				(					SpawnRcMenu()				)				else				(					local hit = dgv_tools.hitTest args.location.x args.location.y					if hit.type == hit.type.cell then					(						local clickedCell = dgv_tools.rows.item[hit.RowIndex].Cells.item[hit.ColumnIndex].tag                        self.RunTool clickedCell					)				)			)            			on dNtab_switch click args do			(                if args.button == dNtab_switch.mouseButtons.right then				(					SpawnRcMenu()				)				else				(                     RefreshDataGrid dgv_tools tab:dNtab_switch.selectedTab.text                )			)            			on dgv_tools cellMouseEnter args do			(				dgv_tools.rows.item[0].cells.item[args.columnIndex].selected = True                				local toolText = tabDic[args.columnIndex+1][5].item["tooltip"]                				if toolText == undefined then toolText = tabDic[args.columnIndex+1][5].item["name"]                    				::DotNetUI.initToolTip dgv_tools toolText			)            			on dgv_tools cellMouseLeave args do			(				::DotNetUI.destroyToolTip()			)		)				createDialog ro				cui.RegisterDialogBar this.ro style:#(#cui_dock_top, #cui_dock_bottom, #cui_max_sized) --#cui_handles, #cui_floatable,				local iniDockState = GetIniSetting this.tabIni "UI" "DockState"				if iniDockState == "Close" then		(			iniDockState = "cui_dock_top"			setIniSetting this.tabIni "UI" "DockState" "cui_dock_top"		)				cui.DockDialogBar this.ro  ( iniDockState as name )				ro._init this	),		fn Run =	(		/* 		The struct is already instantiated, this sets up the UI		 */		if not (hasIniSetting tabIni "UI" "DockState") then setIniSetting tabIni "UI" "DockState" "cui_dock_top"		if (getIniSetting tabIni "UI" "DockState") == "Close" then return format "***** Tab Menu initialized but not displayed *****\n"		Ui()	),		fn GetModule =    (        ( GetThisScriptFileName() )    ),        fn Help =    (        ::mxs.GetScriptHelp ( GetThisScriptFileName() )    ),		fn __init__ =	(		if showUi then this.Run()	),		init = __init__())::TabMenu = TabMenu()