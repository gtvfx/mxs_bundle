/***************************************************************************************************Copyright (C) 2013 - 2014  Gavyn ThompsonThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation; either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program. if not, see <http://www.gnu.org/licenses/>.***************************************************************************************************//***************************************************************************************************Author:				Gavyn ThompsonCompany:				GTVFXWebsite:				www.gtvfx.comEmail:				gthompson@gtvfx.comScriptVersion:			v1.00Updated:				07/31/2014[Purpose]Manage all map loaders in your scene***************************************************************************************************/try(destroyDialog _mapInsp.ro)catch()struct mapInspectorStruct(	self,	ro,	ro_prog,	rcm_uiBar,	mapLoaderArr = #(),	loaderCount,	refsArr = #(),	missingFileCount = 0,	mapInstancer = False,	materialList = #(),	storedMaterial,		fn collectMaterials excludeList:#(VRaySky) =	(		materialList = for i in sceneMaterials where (findItem excludeList (classOf i)) == 0 collect i	),	fn genPropStream nd stream:undefined =	(		prps = #()		if stream == undefined then stream = "" as stringstream		try(prps = getPropNames nd)catch()		for p in prps do		(			try(val = getProperty nd p)catch(val = "")			format "%:%\n" p val to:stream			genPropStream val stream:stream		)		stream	),	fn genHashForLoader mapLoader =	(		str = "" as stringStream		str = genPropStream mapLoader		str = tolower (str as string)		out = (getHashValue str 0)		out	),	fn getMapLoaders inst:False  =	(		out = #()		hashArr = #()		loaders = (getClassInstances bitMapTexture) + (getClassInstances VRayHDRi)		loaderCount = loaders.count		if inst then		(			progressStart "Comparing Map Loaders:"			perc = (100.0 / loaders.count)			percentu = perc			for i in loaders do			(				case (classOf i) of				(					(bitMapTexture):					(						if i.filename == undefined then						(							progressUpdate percentu							percentu += perc							continue						)					)					(VRayHDRi):					(						if i.HDRiMapName == undefined then						(							progressUpdate percentu							percentu += perc							continue						)					)				)				hashVal = genHashForLoader i				indx = finditem hashArr hashVal				case indx of				(					0:					(						append hashArr hashVal						append out #(i)					)					default:					(						append out[indx] i					)				)				progressUpdate percentu				percentu += perc			)			progressEnd()		)		else		(			out = loaders		)		mapLoaderArr = out		out	),	fn instanceLoaders data:undefined =	(		if data == undefined then data = (getMapLoaders inst:True)		setCommandPanelTaskMode #create		progressStart "Instancing Loaders:"		perc = (100.0 / data.count)		percentu = perc		for d in data do		(			for i = 2 to d.count do replaceInstances d[i] d[1]			progressUpdate percentu			percentu += perc		)		progressEnd()		True	),	fn get_names name a =	(		append a name	),	fn collectMissingFiles =	(		arr = #()		enumerateFiles get_names arr #missing		arr	),	fn getMapLoaderByName mapName dataArr:undefined =	(		arr = #()		if dataArr == undefined then dataArr = ((getClassInstances bitMapTexture) + (getClassInstances VRayHDRi))		for i in dataArr do		(			if matchPattern i.name pattern:mapName then append arr i		)		arr	),	fn getMapLoadersByFileName fName dataArr:undefined =	(		arr = #()		if dataArr == undefined then dataArr = ((getClassInstances bitMapTexture) + (getClassInstances VRayHDRi))		for i in dataArr do		(			case (classOf i) of			(				(VrayHDRi):				(					if i.HDRIMapName != undefined and  matchPattern i.HDRIMapName pattern:fName then append arr i				)				(BitmapTex):				(					if i.fileName != undefined and matchPattern i.fileName pattern:fName then append arr i				)			)		)		--for i in (getClassInstances bitMapTexture) where i.fileName != undefined and matchPattern i.fileName pattern:fName do append arr i		--for i in (getClassInstances VRayHDRi) where i.HDRIMapName != undefined and  matchPattern i.HDRIMapName pattern:fName do append arr i		--format "***** Loaders: % *****\n" arr		arr	),	fn getMapLoaderFileName mapLoader =	(		case (classOf mapLoader) of		(			(bitMapTexture):			(				out = mapLoader.fileName			)			(VRayHDRi):			(				out = mapLoader.HDRIMapName			)			default:			(				format "***** Unknown map loader: % | % *****\n" mapLoader (classOf mapLoader)				out = "Unknown"			)		)		out	),	fn getMapLoaderFileNames mapLoaders =	(		arr = #()		for i in mapLoaders do		(			case (classOf i) of			(				(bitMapTexture):				(					appendIfUnique arr i.fileName				)				(VRayHDRi):				(					appendIfUnique arr i.HDRIMapName				)			)		)		arr	),	fn getUsedMaps =	(		arr = usedMaps()		arr	),	fn collectRefs map =	(		arr = refs.dependents map		arr	),	fn getTexmapRes texFileName =	(		if doesFileExist texFileName then		(			bMapFile = openBitmap texFileName			resStr = ((bMapFile.width as string)+"x"+(bMapFile.height as string))			format "***** %: % *****\n" (getFileNameFile texFileName) ((bMapFile.width as string)+" x "+(bMapFile.height as string))			close bMapFile			resStr		)		else		(			False		)	),	fn removeBitmapSubs map =	(		MatEditor.close()		tvps = (getclassinstances bitmapTex asTrackViewPick:True) + (getclassinstances VRayHDRi asTrackViewPick:True)		for tvp in tvps do		(			client = tvp.client			format "***** Client Class: % *****\n" (classOf client)			case (classOf client) of			(				(Material_Editor):				(					format "***** Medit: % *****\n" tvp					if tvp.client[tvp.subNum] == map do					(						tvp.client[tvp.subNum] = standard()					)				)				(MaterialLibrary):				(					format "***** Medit: % *****\n" tvp					if tvp.client[tvp.subNum] == map do					(						tvp.client[tvp.subNum] = standard()					)				)				default:				(					format "***** Texmaps: % *****\n" tvp					if tvp.client[tvp.subNum].value == map do					(						tvp.client[tvp.subNum].value = undefined					)				)			)		)	),	fn checkFileExists texmap =	(		if (texmap != undefined) then		(			case (classOf texmap) of			(				(Bitmaptexture):				(					mapFile = texmap.filename					if mapFile == undefined then return undefined					exists = (doesFileExist mapFile)					--format "***** Bitmap: % | Exists: % *****\n" mapFile exists					if not exists then					(						return undefined					)				)				(VRayHDRi):				(					mapFile = texmap.HDRIMapName					if mapFile == undefined then return undefined					exists = (doesFileExist mapFile)					--format "***** VRayHDRi: % | Exists: % *****\n" mapFile exists					if not exists then					(						return undefined					)				)				default:				(					for i = 1 to (getNumSubTexmaps texmap) do					(						if checkFileExists (getSubTexmap texmap i) == undefined then						(							setSubTexMap texmap i undefined							missingFileCount += 1						)					)					False				)			)		)		False	),	fn RemoveImageLoadersWithMissingFiles mat =	(		if mat == undefined then return False		format "***** Material: % *****\n" mat.name		numSubMats = (getNumSubMtls mat)		if numSubMats != 0 then		(			for i = 1 to numSubMats do			(				removeImageLoadersWithMissingFiles (getSubMtl mat i)			)		)		numSubTexmaps = (getNumSubTexmaps mat)		if numSubTexmaps != 0 then		(			for i = 1 to numSubTexmaps do			(				if checkFileExists (getSubTexmap mat i) == undefined then				(					setSubTexMap mat i undefined					missingFileCount += 1				)			)		)	),	fn RenameMapLoadersToFileName loaderArr:#() =	(		loaderArr = (getMapLoaders inst:False)		for i in loaderArr do		(			if not (matchPattern i.name pattern:"Map #*") then continue			case (classOf i) of			(				(BitmapTexture):				(					i.name = (getFileNameFile i.fileName)				)				(VrayHDRi):				(					i.name = (getFileNameFile i.HDRIMapName)				)			)		)	),	fn ViewMap mapLoader =	(		bm = undefined		case (classOf mapLoader) of		(			(VrayHDRi):			(				bm = bitmapTex fileName:mapLoader.HDRiMapName			)			(BitmapTex):			(				bm = bitmapTex fileName:mapLoader.fileName			)		)		if storedMaterial == undefined then storedMaterial = meditMaterials[24]		meditMaterials[24] = standard()		activeMeditSlot = 24		meditMaterials[24] = bm		MatEditor.Open()		bm.viewImage()	),	fn MenuBar =	(		rcmenu rcm_uiBar		(			local self			subMenu "Tools"			(				menuItem itm_getDups "Assess Duplicate Loaders"				menuItem itm_instance "Instance Loaders"				separator sep_mb_1a				menuItem itm_removeMissing "Remove Unresolved Loaders"				menuItem itm_mapNames "Rename Map Loaders"			)			on itm_getDups picked do			(				--self.ro.dNtab_show.selectedIndex = 1				colAr = #()				append colAr #(#Text,"Map Name",True,#left)				append colAr #(#Text, "Dups",True,#center)				append colAr #(#Text, "Filename",True,#left)				append colAr #(#Text,"Format",True,#center)				self.ro.initDgv self.ro.dgv_data 10 colAr				if not self.mapInstancer then				(					self.getMapLoaders inst:True					self.mapInstancer = True				)				self.ro.drawData self.ro.dgv_data self.mapLoaderArr nested:True				itm_instance.enabled = True			)			on itm_instance picked do			(				self.instanceLoaders data:self.mapLoaderArr				self.getMapLoaders inst:True				self.ro.drawData self.ro.dgv_data self.mapLoaderArr nested:True			)			on itm_removeMissing picked do			(				clearListener()				self.collectMaterials()				for i in self.materialList do				(					self.removeImageLoadersWithMissingFiles i				)				format "***** % files removed *****\n" self.missingFileCount				self.ro.refreshDataGrid self.ro.dgv_data			)			on itm_mapNames picked do			(				if queryBox "This will rename all map loaders to the filename they are loading\n\nContinue?" title:"GTVFX" then				(					self.renameMapLoadersToFileName loaderArr:self.mapLoaderArr					self.ro.refreshDataGrid self.ro.dgv_data				)			)			fn _init pself =			(				self = pself				itm_instance.enabled = False			)		)		rcm_uiBar	),	fn UiDeps =	(		rollout ro_deps "Dependents" width:500		(			local self			fn _init pself =			(				self = pself			)		)		createDialog ro_deps		ro_deps._init self	),	fn UiMapStats =	(		False	),	fn UiProg =	(		rollout ro_prog "" width:500		(			local self			label lbl_prg "Drawing Data:" align:#left			progressBar prg_main color:orange			fn _init pself =			(				self = pself			)		)		createDialog ro_prog		ro_prog._init self	),	fn Ui =	(		rollout ro "Map Inspector by GTVFX" width:850		(			local self			local tab = 1			local uiDic			local initSize			local rcm_UI			local dnToolTip			local clrWindow = ((colorMan.getColor #window)*255)			local clrText = ((colorMan.getColor #text)*255)			local ClrBackGround = ((colorMan.getColor #background)*255)			local tHeight = 12			local jpgClr = (dotnetClass "System.Drawing.Color").lightGreen			local exrClr = (dotnetClass "System.Drawing.Color").SkyBlue			local defClr = (dotnetClass "System.Drawing.Color").plum			local missingClr = (dotnetClass "System.Drawing.Color").tomato			local bmpClr = (dotnetClass "System.Drawing.Color").dodgerblue			local pngClr = (dotnetClass "System.Drawing.Color").fromARGB 252 145 27			local tgaClr = (dotnetClass "System.Drawing.Color").fromARGB 155 250 58			local txClr = (dotnetClass "System.Drawing.Color").lime			local psdClr = (dotnetClass "System.Drawing.Color").yellow			checkBox chk_sMapName "Search By Map Name" across:2			checkBox chk_sFileName "Search By Filename" checked:True offset:[-250,0]			dotNetControl dNtxt_search "Textbox" height:20			dotNetControl dNlbl_stats "Label" width:200 height:20 offset:[0,10]			dotNetControl dgv_data "DataGridView" align:#left  height:400			hyperLink hyp_website "www.gtvfx.com" color:orange  hoverColor:red visitedColor:orange address:"http://www.gtvfx.com"			fn NormalizeRGB val =			(				if val <0 then val = 0 else if val >255 then val = 255				val			)			fn InitToolTip dNetObj caption =			(				if dnTooltip == undefined then				(					dnToolTip = dotnetobject "ToolTip"					dnToolTip.AutoPopDelay = 5000					dnToolTip.InitialDelay = 300					dnToolTip.ReshowDelay = 300					dnToolTip.ShowAlways = true					dnToolTip.IsBalloon = true				)				dnToolTip.SetToolTip dNetObj caption			)			fn SetDotNetWidget dNobj caption fontSize colorOffsetInt:0 fontStyle:#bold foreColor:unsupplied =			(				fStyle = case fontStyle of				(					(#bold):					(						((dotNetClass "System.Drawing.FontStyle").bold)					)					(#italic):					(						((dotNetClass "System.Drawing.FontStyle").italic)					)					(#regular):					(						((dotNetClass "System.Drawing.FontStyle").regular)					)				)				dNobj.text = caption				if foreColor == unsupplied then dNobj.forecolor = dNobj.forecolor.FromArgb clrText.x clrText.y clrText.z else dNobj.forecolor = foreColor				dNobj.backColor = dNobj.backcolor.FromArgb (normalizeRGB (ClrBackGround.x+colorOffsetInt)) (normalizeRGB (ClrBackGround.y+colorOffsetInt)) (normalizeRGB (ClrBackGround.z+colorOffsetInt))				dNobj.Font = dotNetObject "System.Drawing.Font" "Tahoma" fontSize fStyle				dNobj.update()			)			fn SetDataGridColor dgv fontSize =			(				dgv.forecolor = dgv.forecolor.FromArgb clrText.x clrText.y clrText.z				dgv.BackgroundColor = dgv.BackgroundColor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.DefaultCellStyle.BackColor = dgv.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				dgv.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				try(dgv.AlternatingRowsDefaultCellStyle.BackColor = dgv.AlternatingRowsDefaultCellStyle.BackColor.FromArgb (clrWindow.x-15) (clrWindow.y-15) (clrWindow.z-15))catch()			)			fn InitTabs dNtab tabArr =			(				dNtab.controls.clear()				setDotNetWidget dNtab "" 11 colorOffsetInt:10				for r in tabArr do				(					tP = dotNetObject "System.Windows.Forms.TabPage"					setDotNetWidget tP r 11 colorOffsetInt:10					dNtab.controls.add tP				)				dNtab.update()			)			fn InitDnetBtn dNbtn caption fontSize style:#popup colorOffsetInt:0 tooltip:"" =			(				case style of				(					#flat:(dNbtn.flatStyle = dNbtn.flatStyle.flat)					#popup:(dNbtn.flatStyle = dNbtn.flatStyle.popup)					#system:(dNbtn.flatStyle = dNbtn.flatStyle.system)				)				setDotNetWidget dNbtn caption fontSize colorOffsetInt:colorOffsetInt				initToolTip dNbtn tooltip				dNbtn.tag = tooltip				dNbtn.update()			)			fn InitTxtBx tbx caption fontSize tooltip:"" =			(				tbx.backcolor = tbx.backcolor.FromArgb clrWindow.x clrWindow.y clrWindow.z				tbx.forecolor = tbx.forecolor.FromArgb clrText.x clrText.y clrText.z				tbx.text = caption				tbx.Font = dotNetObject "System.Drawing.Font" "Calibri" fontSize ((dotNetClass "System.Drawing.FontStyle").bold)				tbx.BorderStyle = (dotNetClass "System.Windows.Forms.BorderStyle").FixedSingle				tbx.MultiLine = false				tbx.AcceptsReturn = false				tbx.AcceptsTab = false				tbx.WordWrap = false				initToolTip tbx tooltip				tbx.update()			)			fn InitDnetLbl lbl caption fontsize fontStyle:#bold foreColor:unsupplied =			(				setDotNetWidget lbl caption fontSize fontStyle:fontStyle foreColor:foreColor			)			fn ChangeDgvCellColor dgvCell color =			(				newStyle = dotNetObject "System.Windows.Forms.DataGridViewCellStyle"				newStyle.foreColor = color				dgvCell.Style = newStyle			)			fn DrawData dgv dataArr nested:False =			(				dgv.rows.clear()				self.uiProg()				perc = (100.0 / dataArr.count)				percentu = perc				for a in dataArr do				(					tempRow = dotNetObject "System.Windows.Forms.DataGridViewRow"					dgv.rows.add tempRow					bMap = undefined					case nested of					(						(True):						(							bMap = a[1]						)						default:						(							bMap = a						)					)					mFileName = (self.getMapLoaderFileName bMap)					type =try(tolower(getFileNameType mFileName))catch("<NA>")					exists = if type != "<NA>" then doesFileExist mFileName else False					count = (if nested then a.count-1 else "?")					tempRow.SetValues #(bMap.name, count, mFileName, type, (classOf bMap as string))					if exists then					(						case type of						(							".jpg":							(								tempRow.DefaultCellStyle.ForeColor = jpgClr							)							".exr":							(								tempRow.DefaultCellStyle.ForeColor = exrClr							)							".png":							(								tempRow.DefaultCellStyle.ForeColor = pngClr							)							".bmp":							(								tempRow.DefaultCellStyle.ForeColor = bmpClr							)							".psd":							(								tempRow.DefaultCellStyle.ForeColor = psdClr							)							".tx":							(								tempRow.DefaultCellStyle.ForeColor = txClr							)							".tga":							(								tempRow.DefaultCellStyle.ForeColor = tgaClr							)							default:							(								tempRow.DefaultCellStyle.ForeColor = defClr							)						)					)					else					(						tempRow.DefaultCellStyle.ForeColor = missingClr					)					self.ro_prog.prg_main.value = percentu					percentu += perc				)				for c = 0 to (dgv.columns.count-1) do				(					case c of					(						2:						(							dgv.columns.item[c].autoSizeMode = dgv.columns.item[c].autoSizeMode.fill						)						default:						(							dgv.columns.item[c].autoSizeMode = dgv.columns.item[c].autoSizeMode.DisplayedCells						)					)				)				dgv.sort dgv.columns.item[(dgv.columns.count-2)] (dotNetClass "System.ComponentModel.ListSortDirection").ascending				dgv.clearSelection()				dgv.update()				self.ro_prog.prg_main.value = 100				destroyDialog self.ro_prog			)			fn InitDgv dgv fontsize colAr tooltip:"" =			(				dgv.Columns.Clear()				dgv.MultiSelect = True				dgv.AllowUserToAddRows = off				dgv.AutoSize = on				dgv.AutoSizeColumnsMode = dgv.AutoSizeColumnsMode.Fill				dgv.ShowEditingIcon = dgv.RowHeadersVisible = off				dnSelectionMode = dotNetClass "System.Windows.Forms.DataGridViewSelectionMode"				dgv.SelectionMode = dnSelectionMode.FullRowSelect				dgv.AllowUserToResizeRows = False				dgv.AllowUserToOrderColumns = False				dgv.AllowUserToResizeColumns = True				dgv.ColumnHeadersHeightSizeMode = dgv.ColumnHeadersHeightSizeMode.DisableResizing				for col in colAr do				(					dnNewColumn					case col[1] of					(						(#Text):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewTextBoxColumn"						(#Bool):dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewCheckBoxColumn"						default:dnNewColumn = dotNetObject "System.Windows.Forms.DataGridViewComboBoxColumn"					)					dnNewColumn.HeaderText = col[2]					dnNewColumn.ReadOnly = col[3]					dnAlignment = dotNetClass "System.Windows.Forms.DataGridViewContentAlignment"					case col[4] of					(						#Right:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleRight						#Center:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleCenter						#Left:		dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft						default:	dnNewColumn.DefaultCellStyle.Alignment = dnAlignment.MiddleLeft					)					dgv.columns.add dnNewColumn				)				setDataGridColor dgv fontSize				for c = 0 to (colAr.count-1) do				(					dgv.columns.item[c].sortMode = (dotNetClass "System.Windows.Forms.DataGridViewColumnSortMode").automatic				)				initToolTip dgv tooltip				dgv.update()			)			fn UpdatedStats =			(				dNlbl_stats.text = ("Map loaders in scene:  " + (self.loaderCount as string))			)			fn RefreshDataGrid dgv pForce:False =			(				colArr = #()				append colArr #(#Text,"Map Name",True,#left)				append colArr #(#Text, "Dups",True,#center)				append colArr #(#Text, "Filename",True,#left)				append colArr #(#Text,"Format",True,#center)				append colArr #(#Text,"Loader Type",True,#center)				initDgv dgv 10 colArr				if self.mapLoaderArr.count == 0 or pForce then				(					self.getMapLoaders()				)				drawData dgv self.mapLoaderArr nested:self.mapInstancer				updatedStats()			)			fn PosHyperLink posX posY =			(				hyp_website.pos = [posX,posY]			)			fn GetDgvCellValue dgv rowIndex cellIndex =			(				out = dgv.rows.item[rowIndex].cells.item[cellIndex].value				out			)			fn UiMenu =			(				rcmenu rcm_UI				(					local self					menuItem itm_viewSelected "View Image"					separator sep_1a					menuItem itm_putToMedit "Put To Medit"					separator sep_1b					menuItem itm_removeSel "Destroy Selected"					separator sep_1c					menuItem itm_getStats "Show File Stats"					on itm_viewSelected picked do					(						selRows = dgv_data.selectedRows						if selRows.count != 1 then return messageBox "This only works on single row selection" title:"GTVFX:"						fileName = selRows.item[0].cells.item[2].value						if doesFileExist fileName then						(							bMap = (self.getMapLoadersByFileName fileName)[1]							if bMap != undefined then							(								self.ViewMap bMap							)							else							(								messageBox "Could not find map loader..." title:"GTVFX:"							)						)						else						(							messageBox "File does not exist..." title:"GTVFX:"						)					)					on itm_putToMedit picked do					(						selRows = dgv_data.selectedRows						if selRows.count != 1 then return messageBox "This only works on single row selection" title:"GTVFX:"						mapName = selRows.item[0].cells.item[0].value						bMap = (self.getMapLoaderByName mapName)[1]						if bMap != undefined then						(							meditMaterials[activeMeditSlot] = bMap						)						else						(							messageBox "Could not find map loader..." title:"GTVFX:"						)					)					on itm_removeSel picked do					(						selRows = dgv_data.selectedRows						progressStart "Removing maps:"						perc = (100.0 / (selRows.count))						percentu = perc						for i = 0 to (selRows.count-1) do						(							loaderName = selRows.item[i].cells.item[0].value							bMaps = self.getMapLoaderByName loaderName							for bMap in bMaps do							(								self.removeBitmapSubs bMap							)							progressUpdate percentu							percentu += perc						)						progressEnd()						self.ro.refreshDataGrid self.ro.dgv_data pForce:True					)					on itm_getStats picked do					(						format "***** Get Stats *****\n"						/*						selRows = dgv_data.selectedRows						deps = collectDependentNodes selRows						clearSelection()						if deps.count != 0 then select deps else messageBox "No Dependencies\nIf your selection is a textureMap then this is just a map floating in a material editor slot" title:"GTVFX:"						 */					)					fn _init pself =					(						self = pself					)				)				rcm_UI			)			fn _init pself =			(				self = pself				initTxtBx dNtxt_search "Search" 12 tooltip:"Filter rows\nDouble-Click to clear contents"				initDnetLbl dNlbl_stats "Map loaders in scene:" 9 fontStyle:#regular foreColor:((dotnetClass "System.Drawing.Color").fromARGB 255 127.5 0)				refreshDataGrid dgv_data			)			fn FilterDataGridRows dgv cellIndex filterTxt = -- function for the search feature			(				if filterTxt == "" or filterTxt == "Search" then				(					for i in 0 to dgv.rows.count-1 do					(						dgv.rows.item[i].visible = true					)				)				else				(					for i in 0 to dgv.rows.count-1 do					(						if not matchPattern dgv.rows.item[i].cells.item[cellIndex].value pattern:("*"+filterTxt+"*") then						(							dgv.rows.item[i].visible = false						)						else						(							dgv.rows.item[i].visible = true						)					)				)			)			fn GetUiControlName uiControl =			(				str = (uiControl as string)				uiName = (filterString str ":")[2]				uiName			)			fn GetControlByName controlName =			(				out = (for i in self.ro.controls where matchPattern (i as string) pattern:("*:"+controlName+"*") collect i)[1]				out			)			fn CollectUiControls =			(				dic = dotNetObject "System.Collections.Hashtable"				subDic = dotNetObject "System.Collections.Hashtable"				subDic.add "width" ro.width				subDic.add "height" ro.height				dic.add "ui" subDic				for c in ro.controls where (isproperty c #width) and (isproperty c #height) do				(					subDic = dotNetObject "System.Collections.Hashtable"					subDic.add "width" c.width					subDic.add "height" c.height					subDic.add "pos.x" c.pos.x					subDic.add "pos.y" c.pos.y					dic.add (getUiControlName c) subDic				)				dic			)			fn ResizeUI val =			(				dif = (val - initSize)				offMult = 1				c = getControlByName "dNtxt_search"				c.width = (uiDic.item["dNtxt_search"].item["width"] + dif.x)				c = getControlByName "dgv_data"				c.width = (uiDic.item["dgv_data"].item["width"] + dif.x)				c.height = (uiDic.item["dgv_data"].item["height"] + (dif.y*offMult))				posHyperLink (self.ro.width/2-40) (self.ro.height - 20)			)			on chk_sMapName changed state do			(				chk_sFileName.state = not state			)			on chk_sFileName changed state do			(				chk_sMapName.state = not state			)			on dgv_data mouseDown arg do			(				if arg.button == dgv_data.mouseButtons.right then				(					popUpMenu (uiMenu()) pos:mouse.screenPos					rcm_UI._init self				)			)			on dNtxt_search keyUp arg do			(				indx = 2				if chk_sMapName.state then indx = 0				filterDataGridRows dgv_data indx dNtxt_search.text			)			on dNtxt_search MouseDoubleClick arg do			(				dNtxt_search.text = ""				for i in 0 to dgv_data.rows.count-1 do				(					dgv_data.rows.item[i].visible = true				)			)			on dNtxt_search MouseClick arg do			(				if dNtxt_search.text == "Search" then dNtxt_search.text = ""			)			on ro open do			(				posHyperLink (ro.width/2-40) (ro.height - 20)				initSize = [ro.width,ro.height]				uiDic = collectUiControls()			)			on ro close do			(				if self.storedMaterial != undefined then meditMaterials[24] = self.storedMaterial			)			on ro help do			(				format "***** Coming Soon *****\n"			)			on ro resized val do			(				resizeUI val			)		)		createDialog ro menu:(menuBar()) style:#(#style_titlebar, #style_resizing, #style_sunkenedge, #style_sysmenu, #style_minimizebox, #style_maximizebox)		ro._init self		rcm_uiBar._init self	),	fn _init =	(		self = this		ui()	),	init = _init())_mapInsp = mapInspectorStruct()format "***** Struct Instance: _mapInsp *****\n"